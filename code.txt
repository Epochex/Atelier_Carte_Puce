STRUCTURE:
CartePuce/
├── .gitignore
├── README.md
├── config.yaml
├── data/
  ├── app.db
  ├── camera_test.png
  ├── templates/
    ├── alice.png
    ├── lin.png
├── get_code.py
├── requirements.txt
├── scripts/
  ├── __init__.py
  ├── demo_run.py
  ├── enroll_user.py
  ├── init_db.py
  ├── test_camera.py
  ├── test_card.py
├── src/
  ├── __init__.py
  ├── auth_flow.py
  ├── bio.py
  ├── camera.py
  ├── card.py
  ├── config.py
  ├── db.py
  ├── security.py


FILE: get_code.py

from pathlib import Path

root = Path(".").resolve()
output = root / "code.txt"

EXCLUDE_DIRS = {
    ".git",
    "__pycache__",
    ".venv",
    "venv",
    "env",
    ".env",
    ".idea",
    ".vscode",
    ".mypy_cache",
    ".pytest_cache",
    ".ruff_cache",
    "node_modules",
    "dist",
    "build",
}

EXCLUDE_FILES = {"code.txt"}
EXCLUDE_SUFFIXES = {".pyc", ".pyo", ".pyd", ".so", ".dll", ".dylib"}


def should_skip(path: Path) -> bool:
    rel = path.relative_to(root)
    if set(rel.parts) & EXCLUDE_DIRS:
        return True

    if path.is_file():
        if path.name in EXCLUDE_FILES:
            return True
        if path.suffix.lower() in EXCLUDE_SUFFIXES:
            return True

    return False


def print_tree(out, root_path: Path) -> None:
    out.write("STRUCTURE:\n")
    out.write(f"{root_path.name}/\n")

    for path in sorted(root_path.rglob("*")):
        if should_skip(path):
            continue

        rel = path.relative_to(root_path)
        depth = len(rel.parts) - 1
        indent = "  " * depth

        if path.is_dir():
            out.write(f"{indent}├── {path.name}/\n")
        else:
            out.write(f"{indent}├── {path.name}\n")

    out.write("\n\n")


with output.open("w", encoding="utf-8") as out:
    print_tree(out, root)

    py_files = sorted(p for p in root.rglob("*.py") if p.is_file() and not should_skip(p))
    for p in py_files:
        out.write(f"FILE: {p.relative_to(root)}\n\n")
        try:
            out.write(p.read_text(encoding="utf-8"))
        except UnicodeDecodeError:
            out.write(p.read_text(encoding="latin-1", errors="replace"))
        out.write("\n\n")

print("Filtered directory tree + Python code saved to code.txt")


FILE: scripts/__init__.py



FILE: scripts/demo_run.py

from src.config import load_config
from src.db import connect, init_db
from src.auth_flow import run_auth_flow
from src.card import open_card


def main():
    cfg = load_config("config.yaml")
    conn = connect(cfg.db_path)
    init_db(conn)

    s = open_card(10)
    card_uid = s.get_uid_or_none()
    if not card_uid:
        print("DENY  user=None bio_score=None reason=unknown_card")
        return

    print(f"[card] detected card_id={card_uid} atr={s.atr_hex}")

    pin = input("Enter PIN/mot de passe: ").strip()

    result = run_auth_flow(cfg, conn, card_id=card_uid, pin=pin)

    if result.decision == "ALLOW":
        print(f"ALLOW user={result.user_id} bio_score={result.bio_score:.3f} reason={result.reason}")
    else:
        print(f"DENY  user={result.user_id} bio_score={result.bio_score} reason={result.reason}")


if __name__ == "__main__":
    main()


FILE: scripts/enroll_user.py

import os
import argparse
import cv2

from src.config import load_config
from src.db import connect, init_db, upsert_user, upsert_biometric
from src.security import pbkdf2_hash_pin
from src.camera import CameraParams, capture_frame
from src.bio import sha256_file
from src.card import open_card


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--user-id", required=True)
    args = parser.parse_args()

    cfg = load_config("config.yaml")
    conn = connect(cfg.db_path)
    init_db(conn)

    pin = input("Enter PIN/mot de passe: ").strip()
    if not pin:
        raise SystemExit("PIN empty")

    salt, ph = pbkdf2_hash_pin(pin)

    os.makedirs("data/templates", exist_ok=True)

    frame = capture_frame(CameraParams(
        index=cfg.camera.index,
        warmup_frames=cfg.camera.warmup_frames,
        width=cfg.camera.width,
        height=cfg.camera.height,
    ))

    template_path = f"data/templates/{args.user_id}.png"
    cv2.imwrite(template_path, frame)
    tpl_sha = sha256_file(template_path)

    s = open_card(10)
    card_uid, wrote = s.provision_or_load_uid(user_id=args.user_id, tpl_sha256_hex=tpl_sha)

    print(f"[card] card_id={card_uid} atr={s.atr_hex}")
    print(f"[card] write_app_record={wrote}")

    upsert_user(conn, args.user_id, card_uid, salt, ph)
    upsert_biometric(conn, args.user_id, template_path, tpl_sha, algo="ORB+facecrop")

    print(f"ENROLL OK: user_id={args.user_id}, template={template_path}")


if __name__ == "__main__":
    main()


FILE: scripts/init_db.py

from src.config import load_config
from src.db import connect, init_db

def main():
    cfg = load_config("config.yaml")
    conn = connect(cfg.db_path)
    init_db(conn)
    print(f"DB initialized: {cfg.db_path}")

if __name__ == "__main__":
    main()


FILE: scripts/test_camera.py

import cv2
from src.config import load_config
from src.camera import CameraParams, capture_frame

def main():
    cfg = load_config("config.yaml")
    frame = capture_frame(CameraParams(
        index=cfg.camera.index,
        warmup_frames=cfg.camera.warmup_frames,
        width=cfg.camera.width,
        height=cfg.camera.height,
    ))
    cv2.imwrite("data/camera_test.png", frame)
    print("OK: saved data/camera_test.png")

if __name__ == "__main__":
    main()


FILE: scripts/test_card.py

from src.card import get_card_id

def main():
    info = get_card_id(simulate_card=None, timeout_seconds=30)
    print(f"card_id(ATR) = {info.card_id}")

if __name__ == "__main__":
    main()


FILE: src/__init__.py



FILE: src/auth_flow.py

# FILE: /home/vboxuser/Desktop/CartePuce/src/auth_flow.py
from __future__ import annotations
import os
import cv2
from dataclasses import dataclass
from typing import Optional

from .config import AppConfig
from .db import get_user_by_card, log_auth
from .security import verify_pin
from .camera import CameraParams, capture_frame
from .bio import compare_biometric


@dataclass
class AuthResult:
    decision: str  # "ALLOW" | "DENY"
    reason: str
    user_id: Optional[str] = None
    bio_score: Optional[float] = None


def run_auth_flow(cfg: AppConfig, conn, card_id: str, card_atr: Optional[str], pin: str) -> AuthResult:
    """
    card_id: 实际是 card_uid（从卡内 APDU 读出/初始化）
    """
    user = get_user_by_card(conn, card_id)
    if not user:
        log_auth(conn, card_id, card_atr, None, False, None, "DENY", "unknown_card")
        return AuthResult(decision="DENY", reason="unknown_card")

    user_id = user["user_id"]

    # 1) PIN verification
    pwd_ok = verify_pin(pin, user["pwd_salt"], user["pwd_hash"])
    if not pwd_ok:
        log_auth(conn, card_id, card_atr, user_id, False, None, "DENY", "bad_pin")
        return AuthResult(decision="DENY", reason="bad_pin", user_id=user_id)

    # 2) camera catch
    frame = capture_frame(CameraParams(
        index=cfg.camera.index,
        warmup_frames=cfg.camera.warmup_frames,
        width=cfg.camera.width,
        height=cfg.camera.height,
    ))

    # 3) biologi model invoke
    template_path = user.get("template_path")
    if not template_path or not os.path.exists(template_path):
        log_auth(conn, card_id, card_atr, user_id, True, None, "DENY", "no_biometric_template")
        return AuthResult(decision="DENY", reason="no_biometric_template", user_id=user_id)

    template = cv2.imread(template_path)
    if template is None:
        log_auth(conn, card_id, card_atr, user_id, True, None, "DENY", "template_read_error")
        return AuthResult(decision="DENY", reason="template_read_error", user_id=user_id)

    # compartion
    score = compare_biometric(
        captured_bgr=frame,
        template_bgr=template,
        use_face_crop=cfg.biometric.use_face_crop,
        nfeatures=cfg.biometric.orb_nfeatures,
    )

    if score >= cfg.biometric.score_threshold:
        log_auth(conn, card_id, card_atr, user_id, True, score, "ALLOW", "ok")
        return AuthResult(decision="ALLOW", reason="ok", user_id=user_id, bio_score=score)

    log_auth(conn, card_id, card_atr, user_id, True, score, "DENY", "biometric_mismatch")
    return AuthResult(decision="DENY", reason="biometric_mismatch", user_id=user_id, bio_score=score)


FILE: src/bio.py

from __future__ import annotations
import hashlib
import os
from typing import Tuple, Optional

import cv2
import numpy as np


def sha256_file(path: str) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()


def _largest_face_bbox(faces) -> Optional[Tuple[int, int, int, int]]:
    if faces is None or len(faces) == 0:
        return None
    # faces: (x,y,w,h)
    faces = sorted(faces, key=lambda b: b[2] * b[3], reverse=True)
    return tuple(int(v) for v in faces[0])


def preprocess_image(img_bgr: np.ndarray, use_face_crop: bool = True, size: int = 320) -> np.ndarray:
    gray = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)

    if use_face_crop:
        try:
            cascade_path = os.path.join(cv2.data.haarcascades, "haarcascade_frontalface_default.xml")
            face_cascade = cv2.CascadeClassifier(cascade_path)
            faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(80, 80))
            bbox = _largest_face_bbox(faces)
            if bbox:
                x, y, w, h = bbox
                crop = gray[y:y+h, x:x+w]
                crop = cv2.resize(crop, (size, size), interpolation=cv2.INTER_AREA)
                return crop
        except Exception:
            pass

    # fallback: center crop
    h, w = gray.shape[:2]
    m = min(h, w)
    x0 = (w - m) // 2
    y0 = (h - m) // 2
    crop = gray[y0:y0+m, x0:x0+m]
    crop = cv2.resize(crop, (size, size), interpolation=cv2.INTER_AREA)
    return crop


def orb_score(img1_gray: np.ndarray, img2_gray: np.ndarray, nfeatures: int = 800) -> float:
    orb = cv2.ORB_create(nfeatures=nfeatures)
    kp1, des1 = orb.detectAndCompute(img1_gray, None)
    kp2, des2 = orb.detectAndCompute(img2_gray, None)

    if des1 is None or des2 is None or len(des1) == 0 or len(des2) == 0:
        return 0.0

    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
    matches = bf.match(des1, des2)

    if not matches:
        return 0.0

    matches = sorted(matches, key=lambda m: m.distance)
    good = [m for m in matches if m.distance < 50]  
    score = len(good) / max(len(matches), 1)
    return float(score)


def compare_biometric(captured_bgr: np.ndarray, template_bgr: np.ndarray,
                      use_face_crop: bool, nfeatures: int) -> float:
    a = preprocess_image(captured_bgr, use_face_crop=use_face_crop)
    b = preprocess_image(template_bgr, use_face_crop=use_face_crop)
    return orb_score(a, b, nfeatures=nfeatures)


FILE: src/camera.py

from __future__ import annotations

from dataclasses import dataclass

import cv2
import numpy as np


@dataclass
class CameraParams:
    index: int = 0
    warmup_frames: int = 10
    width: int = 640
    height: int = 480


def capture_frame(params: CameraParams) -> np.ndarray:
    cap = cv2.VideoCapture(params.index)
    if not cap.isOpened():
        raise RuntimeError(
            f"Cannot open camera index={params.index}. "
            f"Check VirtualBox settings (Devices -> Webcams) and permissions."
        )

    cap.set(cv2.CAP_PROP_FRAME_WIDTH, params.width)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, params.height)

    for _ in range(max(1, params.warmup_frames)):
        cap.read()

    ok, frame = cap.read()
    cap.release()

    if not ok or frame is None:
        raise RuntimeError("Camera capture failed (no frame returned).")

    return frame


FILE: src/card.py

from __future__ import annotations

import os
import time
import hashlib
from dataclasses import dataclass
from typing import Optional, Tuple

from smartcard.CardType import ATRCardType
from smartcard.CardRequest import CardRequest
from smartcard.CardConnection import CardConnection
from smartcard.Exceptions import CardConnectionException


class CardError(RuntimeError):
    pass


GCM_ATR = [0x3B, 0x02, 0x53, 0x01]
GCM_ATR_MASK = [0xFF, 0xFF, 0xFF, 0x00]
GCM_CARD_TYPE = ATRCardType(GCM_ATR, GCM_ATR_MASK)

INS_READ = 0xBE
INS_UPDATE = 0xDE
INS_VERIFY = 0x20

ADDR_ISSUER_BASE = 0x01
ADDR_USER1_BASE = 0x10

APP_WORD_BASE = ADDR_USER1_BASE
APP_WORD_LEN = 10

MAGIC = b"CP01"

DEFAULT_CSC0 = b"\xAA\xAA\xAA\xAA"
DEFAULT_CSC1 = b"\x11\x11\x11\x11"
DEFAULT_CSC2 = b"\x22\x22\x22\x22"

VERIFY_TARGET_CSC0 = 0x07
VERIFY_TARGET_CSC1 = 0x39
VERIFY_TARGET_CSC2 = 0x3B


def _sha256(b: bytes) -> bytes:
    return hashlib.sha256(b).digest()


def _chunks4(b: bytes):
    if len(b) % 4 != 0:
        raise CardError("record_len_not_multiple_of_4")
    return [b[i:i + 4] for i in range(0, len(b), 4)]


@dataclass
class AppRecord:
    card_uid: str
    user_hash8: str
    tpl_hash8: str


class CardSession:
    def __init__(self, timeout_seconds: int = 10):
        self.timeout_seconds = timeout_seconds
        self.cla = 0x80
        self._svc = None
        self._conn = None
        self.atr_hex = ""
        self._acquire()

    @property
    def conn(self):
        if self._conn is None:
            raise CardError("no_connection")
        return self._conn

    def _acquire(self) -> None:
        req = CardRequest(timeout=self.timeout_seconds, cardType=GCM_CARD_TYPE)
        svc = req.waitforcard()
        conn = svc.connection
        conn.connect(protocol=CardConnection.T0_protocol)
        atr = bytes(conn.getATR())
        self._svc = svc
        self._conn = conn
        self.atr_hex = " ".join(f"{x:02X}" for x in atr)

    def _reacquire(self) -> None:
        last = None
        for _ in range(3):
            try:
                self._acquire()
                return
            except Exception as e:
                last = e
                time.sleep(0.2)
        raise CardError(f"reacquire_failed: {last}")

    def _transmit(self, apdu) -> Tuple[bytes, int, int]:
        try:
            data, sw1, sw2 = self.conn.transmit(apdu)
            return bytes(data), sw1, sw2
        except CardConnectionException:
            self._reacquire()
            data, sw1, sw2 = self.conn.transmit(apdu)
            return bytes(data), sw1, sw2

    def read_word(self, addr: int) -> bytes:
        apdu = [self.cla, INS_READ, 0x00, addr & 0xFF, 0x04]
        data, sw1, sw2 = self._transmit(apdu)
        if (sw1, sw2) != (0x90, 0x00):
            raise CardError(f"read_word_sw={sw1:02X}{sw2:02X}")
        if len(data) != 4:
            raise CardError("read_word_len")
        return data

    def update_word(self, addr: int, word4: bytes) -> None:
        if len(word4) != 4:
            raise CardError("update_word_len")
        apdu = [self.cla, INS_UPDATE, 0x00, addr & 0xFF, 0x04] + list(word4)
        _, sw1, sw2 = self._transmit(apdu)
        if (sw1, sw2) != (0x90, 0x00):
            raise CardError(f"update_word_sw={sw1:02X}{sw2:02X}")

    def verify(self, target: int, code4: bytes) -> None:
        if len(code4) != 4:
            raise CardError("verify_len")
        apdu = [0x00, INS_VERIFY, 0x00, target & 0xFF, 0x04] + list(code4)
        _, sw1, sw2 = self._transmit(apdu)
        if (sw1, sw2) != (0x90, 0x00):
            raise CardError(f"verify_sw={sw1:02X}{sw2:02X}")

    def get_issuer_sn(self) -> bytes:
        out = b""
        for a in range(ADDR_ISSUER_BASE, ADDR_ISSUER_BASE + 4):
            out += self.read_word(a)
        return out

    def uid_from_issuer(self) -> str:
        issuer = self.get_issuer_sn()
        raw = issuer + bytes.fromhex(self.atr_hex.replace(" ", ""))
        return _sha256(raw)[:16].hex()

    def read_app_record(self) -> Optional[AppRecord]:
        raw = b""
        try:
            for i in range(APP_WORD_LEN):
                raw += self.read_word(APP_WORD_BASE + i)
        except Exception:
            return None

        if raw[:4] != MAGIC:
            return None

        card_uid = raw[4:20].hex()
        user_hash8 = raw[20:28].hex()
        tpl_hash8 = raw[28:36].hex()
        return AppRecord(card_uid=card_uid, user_hash8=user_hash8, tpl_hash8=tpl_hash8)

    def _build_record(self, card_uid16: bytes, user_id: str, tpl_sha256_hex: str) -> bytes:
        user_hash8 = _sha256(user_id.encode("utf-8"))[:8]
        tpl_hash8 = bytes.fromhex(tpl_sha256_hex)[:8]
        tail = b"\x00\x00\x00\x00"
        return MAGIC + card_uid16 + user_hash8 + tpl_hash8 + tail

    def _try_unlock_user1(self) -> None:
        for t, c in [
            (VERIFY_TARGET_CSC1, DEFAULT_CSC1),
            (VERIFY_TARGET_CSC0, DEFAULT_CSC0),
            (VERIFY_TARGET_CSC2, DEFAULT_CSC2),
        ]:
            try:
                self.verify(t, c)
                return
            except Exception:
                continue

    def write_app_record(self, user_id: str, tpl_sha256_hex: str, card_uid16: Optional[bytes] = None) -> str:
        if card_uid16 is None:
            card_uid16 = os.urandom(16)

        rec = self._build_record(card_uid16, user_id, tpl_sha256_hex)
        words = _chunks4(rec)

        self._try_unlock_user1()
        for i, w in enumerate(words):
            self.update_word(APP_WORD_BASE + i, w)

        return card_uid16.hex()

    def provision_or_load_uid(self, user_id: str, tpl_sha256_hex: str) -> Tuple[str, bool]:
        r = self.read_app_record()
        if r is not None:
            return r.card_uid, False
        uid = self.write_app_record(user_id=user_id, tpl_sha256_hex=tpl_sha256_hex, card_uid16=None)
        return uid, True

    def get_uid_or_none(self) -> Optional[str]:
        r = self.read_app_record()
        return None if r is None else r.card_uid


def open_card(timeout_seconds: int = 10) -> CardSession:
    return CardSession(timeout_seconds=timeout_seconds)


FILE: src/config.py

from __future__ import annotations
import yaml
from dataclasses import dataclass
from typing import Any, Dict


@dataclass
class CameraConfig:
    index: int = 0
    warmup_frames: int = 10
    width: int = 640
    height: int = 480


@dataclass
class BiometricConfig:
    score_threshold: float = 0.18
    use_face_crop: bool = True
    orb_nfeatures: int = 800


@dataclass
class AuthConfig:
    max_pin_attempts: int = 1


@dataclass
class AppConfig:
    db_path: str = "data/app.db"
    camera: CameraConfig = CameraConfig()
    biometric: BiometricConfig = BiometricConfig()
    auth: AuthConfig = AuthConfig()


def load_config(path: str = "config.yaml") -> AppConfig:
    with open(path, "r", encoding="utf-8") as f:
        raw: Dict[str, Any] = yaml.safe_load(f) or {}

    cam = raw.get("camera", {}) or {}
    bio = raw.get("biometric", {}) or {}
    auth = raw.get("auth", {}) or {}

    return AppConfig(
        db_path=raw.get("db_path", "data/app.db"),
        camera=CameraConfig(
            index=int(cam.get("index", 0)),
            warmup_frames=int(cam.get("warmup_frames", 10)),
            width=int(cam.get("width", 640)),
            height=int(cam.get("height", 480)),
        ),
        biometric=BiometricConfig(
            score_threshold=float(bio.get("score_threshold", 0.18)),
            use_face_crop=bool(bio.get("use_face_crop", True)),
            orb_nfeatures=int(bio.get("orb_nfeatures", 800)),
        ),
        auth=AuthConfig(
            max_pin_attempts=int(auth.get("max_pin_attempts", 1)),
        ),
    )


FILE: src/db.py

from __future__ import annotations

import os
import sqlite3
from typing import Optional, Any, Dict

SCHEMA_SQL = """
PRAGMA journal_mode=WAL;

CREATE TABLE IF NOT EXISTS users (
  user_id      TEXT PRIMARY KEY,
  card_id      TEXT UNIQUE NOT NULL,
  card_atr     TEXT,
  pwd_salt     BLOB NOT NULL,
  pwd_hash     BLOB NOT NULL,
  created_at   TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE IF NOT EXISTS biometrics (
  user_id         TEXT PRIMARY KEY,
  template_path   TEXT NOT NULL,
  template_sha256 TEXT NOT NULL,
  algo            TEXT NOT NULL,
  created_at      TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY(user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS auth_logs (
  id        INTEGER PRIMARY KEY AUTOINCREMENT,
  ts        TEXT NOT NULL DEFAULT (datetime('now')),
  card_id   TEXT,
  card_atr  TEXT,
  user_id   TEXT,
  pwd_ok    INTEGER,
  bio_score REAL,
  decision  TEXT,
  reason    TEXT
);
"""


def ensure_parent_dir(db_path: str) -> None:
    parent = os.path.dirname(db_path)
    if parent:
        os.makedirs(parent, exist_ok=True)


def connect(db_path: str) -> sqlite3.Connection:
    ensure_parent_dir(db_path)
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row
    return conn


def _ensure_column(conn: sqlite3.Connection, table: str, col: str, ddl: str) -> None:
    cols = [r["name"] for r in conn.execute(f"PRAGMA table_info({table})").fetchall()]
    if col not in cols:
        conn.execute(f"ALTER TABLE {table} ADD COLUMN {ddl}")
        conn.commit()


def init_db(conn: sqlite3.Connection) -> None:
    conn.executescript(SCHEMA_SQL)
    conn.commit()

    _ensure_column(conn, "users", "card_atr", "card_atr TEXT")
    _ensure_column(conn, "auth_logs", "card_atr", "card_atr TEXT")


def upsert_user(
    conn: sqlite3.Connection,
    user_id: str,
    card_id: str,
    pwd_salt: bytes,
    pwd_hash: bytes,
    card_atr: Optional[str] = None,
) -> None:
    conn.execute(
        """
        INSERT INTO users(user_id, card_id, card_atr, pwd_salt, pwd_hash)
        VALUES(?, ?, ?, ?, ?)
        ON CONFLICT(user_id) DO UPDATE SET
          card_id=excluded.card_id,
          card_atr=excluded.card_atr,
          pwd_salt=excluded.pwd_salt,
          pwd_hash=excluded.pwd_hash
        """,
        (user_id, card_id, card_atr, pwd_salt, pwd_hash),
    )
    conn.commit()


def upsert_biometric(
    conn: sqlite3.Connection,
    user_id: str,
    template_path: str,
    template_sha256: str,
    algo: str,
) -> None:
    conn.execute(
        """
        INSERT INTO biometrics(user_id, template_path, template_sha256, algo)
        VALUES(?, ?, ?, ?)
        ON CONFLICT(user_id) DO UPDATE SET
          template_path=excluded.template_path,
          template_sha256=excluded.template_sha256,
          algo=excluded.algo
        """,
        (user_id, template_path, template_sha256, algo),
    )
    conn.commit()


def get_user_by_card(conn: sqlite3.Connection, card_id: str) -> Optional[Dict[str, Any]]:
    row = conn.execute(
        """
        SELECT u.user_id, u.card_id, u.card_atr, u.pwd_salt, u.pwd_hash,
               b.template_path, b.template_sha256, b.algo
        FROM users u
        LEFT JOIN biometrics b ON b.user_id = u.user_id
        WHERE u.card_id = ?
        """,
        (card_id,),
    ).fetchone()
    return dict(row) if row else None


def log_auth(
    conn: sqlite3.Connection,
    card_id: str,
    card_atr: Optional[str],
    user_id: Optional[str],
    pwd_ok: bool,
    bio_score: Optional[float],
    decision: str,
    reason: str,
) -> None:
    conn.execute(
        """
        INSERT INTO auth_logs(card_id, card_atr, user_id, pwd_ok, bio_score, decision, reason)
        VALUES(?, ?, ?, ?, ?, ?, ?)
        """,
        (card_id, card_atr, user_id, int(pwd_ok), bio_score, decision, reason),
    )
    conn.commit()


FILE: src/security.py

from __future__ import annotations
import os
import hashlib
import hmac


def pbkdf2_hash_pin(pin: str, salt: bytes | None = None, iterations: int = 200_000) -> tuple[bytes, bytes]:
    if salt is None:
        salt = os.urandom(16)
    dk = hashlib.pbkdf2_hmac("sha256", pin.encode("utf-8"), salt, iterations, dklen=32)
    return salt, dk


def verify_pin(pin: str, salt: bytes, expected_hash: bytes, iterations: int = 200_000) -> bool:
    dk = hashlib.pbkdf2_hmac("sha256", pin.encode("utf-8"), salt, iterations, dklen=32)
    return hmac.compare_digest(dk, expected_hash)


