STRUCTURE:
CartePuce/
├── .gitignore
├── README.md
├── config.yaml
├── data/
  ├── app.db
  ├── camera_test.png
  ├── templates/
    ├── alice.png
├── get_code.py
├── requirements.txt
├── scripts/
  ├── __init__.py
  ├── demo_run.py
  ├── enroll_user.py
  ├── init_db.py
  ├── test_camera.py
  ├── test_card.py
├── src/
  ├── __init__.py
  ├── auth_flow.py
  ├── bio.py
  ├── camera.py
  ├── card.py
  ├── config.py
  ├── db.py
  ├── security.py


FILE: get_code.py

from pathlib import Path

root = Path(".").resolve()
output = root / "code.txt"

# 你不想出现在树里/源码遍历里的目录
EXCLUDE_DIRS = {
    ".git",
    "__pycache__",
    ".venv",
    "venv",
    "env",
    ".env",
    ".idea",
    ".vscode",
    ".mypy_cache",
    ".pytest_cache",
    ".ruff_cache",
    "node_modules",
    "dist",
    "build",
}

# 你不想出现在输出里的文件（或后缀）
EXCLUDE_FILES = {
    "code.txt",  # 避免把输出文件也写回去
}
EXCLUDE_SUFFIXES = {
    ".pyc",
    ".pyo",
    ".pyd",
    ".so",
    ".dll",
    ".dylib",
}

def should_skip(path: Path) -> bool:
    """
    统一过滤逻辑：只要路径任一层目录在 EXCLUDE_DIRS，就跳过。
    文件名/后缀命中也跳过。
    """
    rel = path.relative_to(root)
    parts = set(rel.parts)

    if parts & EXCLUDE_DIRS:
        return True

    if path.is_file():
        if path.name in EXCLUDE_FILES:
            return True
        if path.suffix.lower() in EXCLUDE_SUFFIXES:
            return True

    return False


def print_tree(out, root_path: Path) -> None:
    out.write("STRUCTURE:\n")
    out.write(f"{root_path.name}/\n")

    # rglob 结果里混合文件和目录；我们过滤后再输出
    for path in sorted(root_path.rglob("*")):
        if should_skip(path):
            continue

        rel = path.relative_to(root_path)
        depth = len(rel.parts) - 1
        indent = "  " * depth

        if path.is_dir():
            out.write(f"{indent}├── {path.name}/\n")
        else:
            out.write(f"{indent}├── {path.name}\n")

    out.write("\n\n")


with output.open("w", encoding="utf-8") as out:
    # 1) 目录结构（如果你连这个也不想要，直接注释掉下一行）
    print_tree(out, root)

    # 2) 打印所有 Python 文件源码（同样过滤噪音目录）
    py_files = sorted(p for p in root.rglob("*.py") if p.is_file() and not should_skip(p))

    for p in py_files:
        out.write(f"FILE: {p.relative_to(root)}\n\n")

        try:
            out.write(p.read_text(encoding="utf-8"))
        except UnicodeDecodeError:
            out.write(p.read_text(encoding="latin-1", errors="replace"))

        out.write("\n\n")

print("Filtered directory tree + python code saved to code.txt")


FILE: scripts/__init__.py



FILE: scripts/demo_run.py

# FILE: /home/vboxuser/Desktop/CartePuce/scripts/demo_run.py
import argparse

from src.config import load_config
from src.db import connect, init_db
from src.card import open_card, get_card_id
from src.auth_flow import run_auth_flow


def main():
    parser = argparse.ArgumentParser()
    # 保留 simulate 仅用于开发；实际 demo 用真实卡时不要传
    parser.add_argument("--simulate-card", default=None, help="DEV ONLY: skip real card and use this as card_id")
    args = parser.parse_args()

    cfg = load_config("config.yaml")
    conn = connect(cfg.db_path)
    init_db(conn)

    # Insertion de la carte
    if args.simulate_card:
        info = get_card_id(simulate_card=args.simulate_card, timeout_seconds=30)
        card_uid = info.card_id
        atr_hex = info.atr_hex
        print(f"[card] SIMULATED card_uid = {card_uid}")
        card_user = None
    else:
        sess = open_card(timeout_seconds=60)
        card_uid = sess.ensure_provisioned()
        atr_hex = sess.atr_hex
        card_user, tpl_prefix = sess.read_user_mapping()
        print(f"[card] reader={sess.reader}")
        print(f"[card] ATR={atr_hex}")
        print(f"[card] card_uid={card_uid}")
        if card_user:
            print(f"[card] card_user_id={card_user} (from card)")
        # tpl_prefix 仅用于展示/调试，不参与安全判断

    # PIN/mot de passe
    pin = input("Enter PIN/mot de passe: ").strip()

    # capture -> comparaison -> DB -> autorisation/refus
    result = run_auth_flow(cfg, conn, card_id=card_uid, card_atr=atr_hex, pin=pin)

    if result.decision == "ALLOW":
        print(f"ALLOW user={result.user_id} bio_score={result.bio_score:.3f} reason={result.reason}")
    else:
        print(f"DENY  user={result.user_id} bio_score={result.bio_score} reason={result.reason}")


if __name__ == "__main__":
    main()


FILE: scripts/enroll_user.py

# FILE: /home/vboxuser/Desktop/CartePuce/scripts/enroll_user.py
import os
import argparse
import cv2

from src.config import load_config
from src.db import connect, init_db, upsert_user, upsert_biometric
from src.security import pbkdf2_hash_pin
from src.card import open_card, get_card_id
from src.camera import CameraParams, capture_frame
from src.bio import sha256_file


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--user-id", required=True, help="e.g. alice")
    # 保留 simulate 仅用于开发；实际 demo 用真实卡时不要传这个参数
    parser.add_argument("--simulate-card", default=None, help="DEV ONLY: skip real card and use this as card_id")
    args = parser.parse_args()

    cfg = load_config("config.yaml")
    conn = connect(cfg.db_path)
    init_db(conn)

    # 1) 卡：真实卡 -> APDU 初始化/读取 card_uid；模拟 -> 直接用 simulate-card
    if args.simulate_card:
        card_info = get_card_id(simulate_card=args.simulate_card, timeout_seconds=30)
        card_uid = card_info.card_id
        atr_hex = card_info.atr_hex
        sess = None
        print(f"[card] SIMULATED card_uid = {card_uid}")
    else:
        sess = open_card(timeout_seconds=60)
        card_uid = sess.ensure_provisioned()
        atr_hex = sess.atr_hex
        print(f"[card] reader={sess.reader}")
        print(f"[card] ATR={atr_hex}")
        print(f"[card] card_uid={card_uid}")

    # 2) PIN / mot de passe（当前先用 DB 校验；后续可以再加卡内 PIN2/3 验证）
    pin = input("Enter PIN/mot de passe: ").strip()
    if not pin:
        raise SystemExit("PIN empty")

    salt, ph = pbkdf2_hash_pin(pin)

    # 3) 摄像头采集：存本地模板文件（演示用）
    os.makedirs("data/templates", exist_ok=True)
    frame = capture_frame(CameraParams(
        index=cfg.camera.index,
        warmup_frames=cfg.camera.warmup_frames,
        width=cfg.camera.width,
        height=cfg.camera.height,
    ))

    template_path = f"data/templates/{args.user_id}.png"
    cv2.imwrite(template_path, frame)
    t_sha = sha256_file(template_path)

    # 4) 写卡：把 user_id + template hash 前缀写进去（纯演示，非安全依据）
    if sess is not None:
        sess.write_user_mapping(user_id=args.user_id, template_sha256_hex=t_sha)
        print("[card] wrote user mapping into card (user_id + template hash prefix)")

    # 5) 写 DB：用 card_uid 做主关联键
    upsert_user(conn, args.user_id, card_uid, salt, ph, card_atr=atr_hex)
    upsert_biometric(conn, args.user_id, template_path, t_sha, algo="ORB+facecrop")
    print(f"ENROLL OK: user_id={args.user_id}, card_uid={card_uid}, template={template_path}")


if __name__ == "__main__":
    main()


FILE: scripts/init_db.py

from src.config import load_config
from src.db import connect, init_db

def main():
    cfg = load_config("config.yaml")
    conn = connect(cfg.db_path)
    init_db(conn)
    print(f"DB initialized: {cfg.db_path}")

if __name__ == "__main__":
    main()


FILE: scripts/test_camera.py

import cv2
from src.config import load_config
from src.camera import CameraParams, capture_frame

def main():
    cfg = load_config("config.yaml")
    frame = capture_frame(CameraParams(
        index=cfg.camera.index,
        warmup_frames=cfg.camera.warmup_frames,
        width=cfg.camera.width,
        height=cfg.camera.height,
    ))
    cv2.imwrite("data/camera_test.png", frame)
    print("OK: saved data/camera_test.png")

if __name__ == "__main__":
    main()


FILE: scripts/test_card.py

from src.card import get_card_id

def main():
    info = get_card_id(simulate_card=None, timeout_seconds=30)
    print(f"card_id(ATR) = {info.card_id}")

if __name__ == "__main__":
    main()


FILE: src/__init__.py



FILE: src/auth_flow.py

# FILE: /home/vboxuser/Desktop/CartePuce/src/auth_flow.py
from __future__ import annotations
import os
import cv2
from dataclasses import dataclass
from typing import Optional

from .config import AppConfig
from .db import get_user_by_card, log_auth
from .security import verify_pin
from .camera import CameraParams, capture_frame
from .bio import compare_biometric


@dataclass
class AuthResult:
    decision: str  # "ALLOW" | "DENY"
    reason: str
    user_id: Optional[str] = None
    bio_score: Optional[float] = None


def run_auth_flow(cfg: AppConfig, conn, card_id: str, card_atr: Optional[str], pin: str) -> AuthResult:
    """
    card_id: 实际是 card_uid（从卡内 APDU 读出/初始化）
    """
    user = get_user_by_card(conn, card_id)
    if not user:
        log_auth(conn, card_id, card_atr, None, False, None, "DENY", "unknown_card")
        return AuthResult(decision="DENY", reason="unknown_card")

    user_id = user["user_id"]

    # 1) PIN 验证（当前先用 DB 校验；后续可加卡内 PIN2/3 VERIFY）
    pwd_ok = verify_pin(pin, user["pwd_salt"], user["pwd_hash"])
    if not pwd_ok:
        log_auth(conn, card_id, card_atr, user_id, False, None, "DENY", "bad_pin")
        return AuthResult(decision="DENY", reason="bad_pin", user_id=user_id)

    # 2) 摄像头抓帧
    frame = capture_frame(CameraParams(
        index=cfg.camera.index,
        warmup_frames=cfg.camera.warmup_frames,
        width=cfg.camera.width,
        height=cfg.camera.height,
    ))

    # 3) 生物模板加载
    template_path = user.get("template_path")
    if not template_path or not os.path.exists(template_path):
        log_auth(conn, card_id, card_atr, user_id, True, None, "DENY", "no_biometric_template")
        return AuthResult(decision="DENY", reason="no_biometric_template", user_id=user_id)

    template = cv2.imread(template_path)
    if template is None:
        log_auth(conn, card_id, card_atr, user_id, True, None, "DENY", "template_read_error")
        return AuthResult(decision="DENY", reason="template_read_error", user_id=user_id)

    # 4) 比对
    score = compare_biometric(
        captured_bgr=frame,
        template_bgr=template,
        use_face_crop=cfg.biometric.use_face_crop,
        nfeatures=cfg.biometric.orb_nfeatures,
    )

    if score >= cfg.biometric.score_threshold:
        log_auth(conn, card_id, card_atr, user_id, True, score, "ALLOW", "ok")
        return AuthResult(decision="ALLOW", reason="ok", user_id=user_id, bio_score=score)

    log_auth(conn, card_id, card_atr, user_id, True, score, "DENY", "biometric_mismatch")
    return AuthResult(decision="DENY", reason="biometric_mismatch", user_id=user_id, bio_score=score)


FILE: src/bio.py

from __future__ import annotations
import hashlib
import os
from typing import Tuple, Optional

import cv2
import numpy as np


def sha256_file(path: str) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()


def _largest_face_bbox(faces) -> Optional[Tuple[int, int, int, int]]:
    if faces is None or len(faces) == 0:
        return None
    # faces: (x,y,w,h)
    faces = sorted(faces, key=lambda b: b[2] * b[3], reverse=True)
    return tuple(int(v) for v in faces[0])


def preprocess_image(img_bgr: np.ndarray, use_face_crop: bool = True, size: int = 320) -> np.ndarray:
    gray = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)

    if use_face_crop:
        try:
            cascade_path = os.path.join(cv2.data.haarcascades, "haarcascade_frontalface_default.xml")
            face_cascade = cv2.CascadeClassifier(cascade_path)
            faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(80, 80))
            bbox = _largest_face_bbox(faces)
            if bbox:
                x, y, w, h = bbox
                crop = gray[y:y+h, x:x+w]
                crop = cv2.resize(crop, (size, size), interpolation=cv2.INTER_AREA)
                return crop
        except Exception:
            pass

    # fallback: center crop
    h, w = gray.shape[:2]
    m = min(h, w)
    x0 = (w - m) // 2
    y0 = (h - m) // 2
    crop = gray[y0:y0+m, x0:x0+m]
    crop = cv2.resize(crop, (size, size), interpolation=cv2.INTER_AREA)
    return crop


def orb_score(img1_gray: np.ndarray, img2_gray: np.ndarray, nfeatures: int = 800) -> float:
    orb = cv2.ORB_create(nfeatures=nfeatures)
    kp1, des1 = orb.detectAndCompute(img1_gray, None)
    kp2, des2 = orb.detectAndCompute(img2_gray, None)

    if des1 is None or des2 is None or len(des1) == 0 or len(des2) == 0:
        return 0.0

    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
    matches = bf.match(des1, des2)

    if not matches:
        return 0.0

    # 距离越小越相似；取“好匹配”占比作为分数
    matches = sorted(matches, key=lambda m: m.distance)
    good = [m for m in matches if m.distance < 50]  # 经验阈值
    score = len(good) / max(len(matches), 1)
    return float(score)


def compare_biometric(captured_bgr: np.ndarray, template_bgr: np.ndarray,
                      use_face_crop: bool, nfeatures: int) -> float:
    a = preprocess_image(captured_bgr, use_face_crop=use_face_crop)
    b = preprocess_image(template_bgr, use_face_crop=use_face_crop)
    return orb_score(a, b, nfeatures=nfeatures)


FILE: src/camera.py

from __future__ import annotations
import cv2
import numpy as np
from dataclasses import dataclass


@dataclass
class CameraParams:
    index: int = 0
    warmup_frames: int = 10
    width: int = 640
    height: int = 480


def capture_frame(params: CameraParams) -> np.ndarray:
    cap = cv2.VideoCapture(params.index)
    if not cap.isOpened():
        raise RuntimeError(f"无法打开摄像头 index={params.index}（检查 VirtualBox Webcams 是否已勾选）")

    cap.set(cv2.CAP_PROP_FRAME_WIDTH, params.width)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, params.height)

    # warmup
    for _ in range(max(1, params.warmup_frames)):
        cap.read()

    ok, frame = cap.read()
    cap.release()
    if not ok or frame is None:
        raise RuntimeError("摄像头抓帧失败")

    return frame  # BGR


FILE: src/card.py

from __future__ import annotations

from dataclasses import dataclass
from typing import Optional, Tuple
import os
import time
import hashlib


@dataclass
class CardInfo:
    card_id: str
    atr_hex: str
    reader: str


class CardError(RuntimeError):
    pass


def _bytes_to_hex(bs: bytes) -> str:
    return " ".join(f"{b:02X}" for b in bs)


def _transmit(conn, apdu: list[int]) -> Tuple[bytes, int, int]:
    data, sw1, sw2 = conn.transmit(apdu)
    return bytes(data), int(sw1), int(sw2)


def _transmit_with_t0_fixes(conn, apdu: list[int]) -> Tuple[bytes, int, int]:
    data, sw1, sw2 = _transmit(conn, apdu)

    if sw1 == 0x6C:
        apdu2 = apdu[:-1] + [sw2]
        data, sw1, sw2 = _transmit(conn, apdu2)

    if sw1 == 0x61:
        le = sw2 if sw2 != 0x00 else 0xFF
        extra, sw1b, sw2b = _transmit(conn, [apdu[0], 0xC0, 0x00, 0x00, le])
        data = data + extra
        sw1, sw2 = sw1b, sw2b

    return data, sw1, sw2


class CardSession:
    MAGIC = b"CP01"
    OFFSET_MAGIC = 0
    OFFSET_UID = 4
    UID_LEN = 16
    OFFSET_USERLEN = 20
    OFFSET_USER = 21
    USER_MAX = 32
    OFFSET_TPL = 53
    TPL_LEN = 16

    def __init__(self, reader, conn, atr: bytes):
        self.reader_obj = reader
        self.conn = conn
        self.atr = atr
        self.cla = 0x00

    @property
    def atr_hex(self) -> str:
        return _bytes_to_hex(self.atr)

    @property
    def reader(self) -> str:
        return str(self.reader_obj)

    def _connect(self) -> None:
        from smartcard.CardConnection import CardConnection
        self.conn.connect(protocol=CardConnection.T0_protocol)

    def _reopen(self) -> None:
        self.conn = self.reader_obj.createConnection()
        self._connect()
        self.atr = bytes(self.conn.getATR())

    def _tx(self, apdu: list[int]) -> Tuple[bytes, int, int]:
        try:
            return _transmit_with_t0_fixes(self.conn, apdu)
        except Exception as e1:
            try:
                try:
                    self.conn.disconnect()
                except Exception:
                    pass
                self._reopen()
                return _transmit_with_t0_fixes(self.conn, apdu)
            except Exception as e2:
                raise CardError(f"transmit_failed: {e1} / reconnect_failed: {e2}")

    def _tx_auto_cla(self, ins: int, p1: int, p2: int, lc_data: Optional[bytes] = None, le: Optional[int] = None) -> Tuple[bytes, int, int]:
        if lc_data is not None and le is not None:
            raise ValueError("bad_apdu_params")

        def build(cla: int) -> list[int]:
            if lc_data is not None:
                return [cla, ins, p1, p2, len(lc_data)] + list(lc_data)
            if le is not None:
                return [cla, ins, p1, p2, le]
            return [cla, ins, p1, p2]

        apdu = build(self.cla)
        data, sw1, sw2 = self._tx(apdu)
        if (sw1, sw2) == (0x6D, 0x00):
            for cand in (0xA0, 0x80, 0x00):
                if cand == self.cla:
                    continue
                data2, sw1b, sw2b = self._tx(build(cand))
                if (sw1b, sw2b) != (0x6D, 0x00):
                    self.cla = cand
                    return data2, sw1b, sw2b
            return data, sw1, sw2
        return data, sw1, sw2

    def read_binary(self, offset: int, length: int) -> bytes:
        if offset < 0 or length <= 0 or length > 0xFF:
            raise ValueError("invalid_offset_or_length")

        p1 = (offset >> 8) & 0xFF
        p2 = offset & 0xFF
        data, sw1, sw2 = self._tx_auto_cla(0xB0, p1, p2, le=length)

        if (sw1, sw2) != (0x90, 0x00):
            raise CardError(f"read_binary_sw={sw1:02X}{sw2:02X}")

        return data

    def update_binary(self, offset: int, data: bytes) -> None:
        if offset < 0 or not data or len(data) > 0xFF:
            raise ValueError("invalid_offset_or_data")

        p1 = (offset >> 8) & 0xFF
        p2 = offset & 0xFF
        _, sw1, sw2 = self._tx_auto_cla(0xD6, p1, p2, lc_data=data)

        if (sw1, sw2) != (0x90, 0x00):
            raise CardError(f"update_binary_sw={sw1:02X}{sw2:02X}")

    def atr_derived_uid(self) -> str:
        d = hashlib.sha256(self.atr).digest()[:16]
        return d.hex()

    def ensure_provisioned(self) -> str:
        try:
            _ = self.read_binary(0, 1)
        except CardError as e:
            if "6D00" in str(e):
                return self.atr_derived_uid()
            raise

        blob = self.read_binary(0, self.OFFSET_TPL + self.TPL_LEN)
        magic = blob[self.OFFSET_MAGIC:self.OFFSET_MAGIC + 4]
        if magic == self.MAGIC:
            uid = blob[self.OFFSET_UID:self.OFFSET_UID + self.UID_LEN]
            if len(uid) == self.UID_LEN and any(b != 0x00 for b in uid):
                return uid.hex()

        uid = os.urandom(self.UID_LEN)
        user_len = bytes([0])
        user_pad = bytes([0] * self.USER_MAX)
        tpl = bytes([0] * self.TPL_LEN)
        payload = self.MAGIC + uid + user_len + user_pad + tpl
        self.update_binary(0, payload)
        return uid.hex()

    def write_user_mapping(self, user_id: str, template_sha256_hex: Optional[str] = None) -> None:
        try:
            _ = self.read_binary(0, 1)
        except CardError as e:
            if "6D00" in str(e):
                return
            raise

        raw = user_id.encode("utf-8", errors="ignore")[:self.USER_MAX]
        user_len = bytes([len(raw)])
        user_pad = raw + bytes([0] * (self.USER_MAX - len(raw)))

        tpl16 = bytes([0] * self.TPL_LEN)
        if template_sha256_hex:
            full = bytes.fromhex(template_sha256_hex.strip())
            tpl16 = full[:self.TPL_LEN].ljust(self.TPL_LEN, b"\x00")

        self.update_binary(self.OFFSET_USERLEN, user_len + user_pad + tpl16)


def open_card(timeout_seconds: int = 30, reader_index: int = 0) -> CardSession:
    from smartcard.System import readers

    rlist = readers()
    if not rlist:
        raise CardError("no_reader")

    if reader_index < 0 or reader_index >= len(rlist):
        raise CardError(f"bad_reader_index: {reader_index}")

    reader = rlist[reader_index]
    deadline = time.time() + max(1, int(timeout_seconds))
    last_err: Optional[Exception] = None

    while time.time() < deadline:
        try:
            conn = reader.createConnection()
            sess = CardSession(reader=reader, conn=conn, atr=b"")
            sess._connect()
            sess.atr = bytes(sess.conn.getATR())
            return sess
        except Exception as e:
            last_err = e
            time.sleep(0.2)

    raise CardError(f"wait_or_connect_failed: {last_err}")


def get_card_id(simulate_card: Optional[str], timeout_seconds: int = 30) -> CardInfo:
    if simulate_card:
        return CardInfo(card_id=simulate_card.strip(), atr_hex="SIMULATED", reader="SIMULATED")

    sess = open_card(timeout_seconds=timeout_seconds)
    uid = sess.ensure_provisioned()
    return CardInfo(card_id=uid, atr_hex=sess.atr_hex, reader=sess.reader)


FILE: src/config.py

from __future__ import annotations
import yaml
from dataclasses import dataclass
from typing import Any, Dict


@dataclass
class CameraConfig:
    index: int = 0
    warmup_frames: int = 10
    width: int = 640
    height: int = 480


@dataclass
class BiometricConfig:
    score_threshold: float = 0.18
    use_face_crop: bool = True
    orb_nfeatures: int = 800


@dataclass
class AuthConfig:
    max_pin_attempts: int = 1


@dataclass
class AppConfig:
    db_path: str = "data/app.db"
    camera: CameraConfig = CameraConfig()
    biometric: BiometricConfig = BiometricConfig()
    auth: AuthConfig = AuthConfig()


def load_config(path: str = "config.yaml") -> AppConfig:
    with open(path, "r", encoding="utf-8") as f:
        raw: Dict[str, Any] = yaml.safe_load(f) or {}

    cam = raw.get("camera", {}) or {}
    bio = raw.get("biometric", {}) or {}
    auth = raw.get("auth", {}) or {}

    return AppConfig(
        db_path=raw.get("db_path", "data/app.db"),
        camera=CameraConfig(
            index=int(cam.get("index", 0)),
            warmup_frames=int(cam.get("warmup_frames", 10)),
            width=int(cam.get("width", 640)),
            height=int(cam.get("height", 480)),
        ),
        biometric=BiometricConfig(
            score_threshold=float(bio.get("score_threshold", 0.18)),
            use_face_crop=bool(bio.get("use_face_crop", True)),
            orb_nfeatures=int(bio.get("orb_nfeatures", 800)),
        ),
        auth=AuthConfig(
            max_pin_attempts=int(auth.get("max_pin_attempts", 1)),
        ),
    )


FILE: src/db.py

# FILE: /home/vboxuser/Desktop/CartePuce/src/db.py
from __future__ import annotations

import os
import sqlite3
from typing import Optional, Any, Dict


SCHEMA_SQL = """
PRAGMA journal_mode=WAL;

CREATE TABLE IF NOT EXISTS users (
  user_id      TEXT PRIMARY KEY,
  card_id      TEXT UNIQUE NOT NULL,  -- 实际存 card_uid（hex）
  card_atr     TEXT,                  -- 记录 ATR 便于审计/排错
  pwd_salt     BLOB NOT NULL,
  pwd_hash     BLOB NOT NULL,
  created_at   TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE IF NOT EXISTS biometrics (
  user_id         TEXT PRIMARY KEY,
  template_path   TEXT NOT NULL,
  template_sha256 TEXT NOT NULL,
  algo            TEXT NOT NULL,
  created_at      TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY(user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS auth_logs (
  id        INTEGER PRIMARY KEY AUTOINCREMENT,
  ts        TEXT NOT NULL DEFAULT (datetime('now')),
  card_id   TEXT,    -- card_uid
  card_atr  TEXT,
  user_id   TEXT,
  pwd_ok    INTEGER,
  bio_score REAL,
  decision  TEXT,
  reason    TEXT
);
"""


def ensure_parent_dir(db_path: str) -> None:
    parent = os.path.dirname(db_path)
    if parent:
        os.makedirs(parent, exist_ok=True)


def connect(db_path: str) -> sqlite3.Connection:
    ensure_parent_dir(db_path)
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row
    return conn


def _ensure_column(conn: sqlite3.Connection, table: str, col: str, ddl: str) -> None:
    cols = [r["name"] for r in conn.execute(f"PRAGMA table_info({table})").fetchall()]
    if col not in cols:
        conn.execute(f"ALTER TABLE {table} ADD COLUMN {ddl}")
        conn.commit()


def init_db(conn: sqlite3.Connection) -> None:
    conn.executescript(SCHEMA_SQL)
    conn.commit()

    # 兼容旧 DB：如果之前没有这些列，补上
    _ensure_column(conn, "users", "card_atr", "card_atr TEXT")
    _ensure_column(conn, "auth_logs", "card_atr", "card_atr TEXT")


def upsert_user(conn: sqlite3.Connection, user_id: str, card_id: str, pwd_salt: bytes, pwd_hash: bytes,
                card_atr: Optional[str] = None) -> None:
    conn.execute(
        """
        INSERT INTO users(user_id, card_id, card_atr, pwd_salt, pwd_hash)
        VALUES(?, ?, ?, ?, ?)
        ON CONFLICT(user_id) DO UPDATE SET
          card_id=excluded.card_id,
          card_atr=excluded.card_atr,
          pwd_salt=excluded.pwd_salt,
          pwd_hash=excluded.pwd_hash
        """,
        (user_id, card_id, card_atr, pwd_salt, pwd_hash),
    )
    conn.commit()


def upsert_biometric(conn: sqlite3.Connection, user_id: str, template_path: str,
                     template_sha256: str, algo: str) -> None:
    conn.execute(
        """
        INSERT INTO biometrics(user_id, template_path, template_sha256, algo)
        VALUES(?, ?, ?, ?)
        ON CONFLICT(user_id) DO UPDATE SET
          template_path=excluded.template_path,
          template_sha256=excluded.template_sha256,
          algo=excluded.algo
        """,
        (user_id, template_path, template_sha256, algo),
    )
    conn.commit()


def get_user_by_card(conn: sqlite3.Connection, card_id: str) -> Optional[Dict[str, Any]]:
    row = conn.execute(
        """
        SELECT u.user_id, u.card_id, u.card_atr, u.pwd_salt, u.pwd_hash,
               b.template_path, b.template_sha256, b.algo
        FROM users u
        LEFT JOIN biometrics b ON b.user_id = u.user_id
        WHERE u.card_id = ?
        """,
        (card_id,),
    ).fetchone()
    return dict(row) if row else None


def log_auth(conn: sqlite3.Connection, card_id: str, card_atr: Optional[str], user_id: Optional[str],
             pwd_ok: bool, bio_score: Optional[float], decision: str, reason: str) -> None:
    conn.execute(
        """
        INSERT INTO auth_logs(card_id, card_atr, user_id, pwd_ok, bio_score, decision, reason)
        VALUES(?, ?, ?, ?, ?, ?, ?)
        """,
        (card_id, card_atr, user_id, int(pwd_ok), bio_score, decision, reason),
    )
    conn.commit()


FILE: src/security.py

from __future__ import annotations
import os
import hashlib
import hmac


def pbkdf2_hash_pin(pin: str, salt: bytes | None = None, iterations: int = 200_000) -> tuple[bytes, bytes]:
    if salt is None:
        salt = os.urandom(16)
    dk = hashlib.pbkdf2_hmac("sha256", pin.encode("utf-8"), salt, iterations, dklen=32)
    return salt, dk


def verify_pin(pin: str, salt: bytes, expected_hash: bytes, iterations: int = 200_000) -> bool:
    dk = hashlib.pbkdf2_hmac("sha256", pin.encode("utf-8"), salt, iterations, dklen=32)
    return hmac.compare_digest(dk, expected_hash)


