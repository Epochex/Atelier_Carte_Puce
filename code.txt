STRUCTURE:
CartePuce/
├── .gitignore
├── README.md
├── config.yaml
├── data/
  ├── app.db
  ├── templates/
    ├── lin.png
  ├── vision_test.png
├── get_code.py
├── requirements.txt
├── scripts/
  ├── __init__.py
  ├── build_vision.sh
  ├── change_pin.py
  ├── demo_run.py
  ├── enroll_user.py
  ├── init_db.py
  ├── probe_access.py
  ├── recover_pin.py
  ├── security_demo.py
  ├── test_camera.py
  ├── test_card.py
  ├── test_vision.py
├── src/
  ├── __init__.py
  ├── auth_flow.py
  ├── bio.py
  ├── camera.py
  ├── card.py
  ├── config.py
  ├── db.py
  ├── security/
    ├── __init__.py
    ├── audit_logging.py
    ├── hmac_challenge_response.py
    ├── password_hashing.py
    ├── replay_protection.py
    ├── template_integrity.py
  ├── vision_backend.py
├── vision/
  ├── CMakeLists.txt
  ├── bin/
    ├── ght_face_eyes
  ├── src/
    ├── ght_face_eyes.cpp


FILE: get_code.py
================================================================================
from pathlib import Path

root = Path(".").resolve()
output = root / "code.txt"

EXCLUDE_DIRS = {
    ".git",
    "__pycache__",
    ".venv",
    "venv",
    "env",
    ".env",
    ".idea",
    ".vscode",
    ".mypy_cache",
    ".pytest_cache",
    ".ruff_cache",
    "node_modules",
    "dist",
    "build",
}

EXCLUDE_FILES = {"code.txt"}
EXCLUDE_SUFFIXES = {".pyc", ".pyo", ".pyd", ".so", ".dll", ".dylib"}

INCLUDE_SUFFIXES = {".py", ".c", ".cpp", ".h", ".hpp", ".sh"}


def should_skip(path: Path) -> bool:
    rel = path.relative_to(root)

    # Skip any path that contains an excluded directory in its components
    if set(rel.parts) & EXCLUDE_DIRS:
        return True

    if path.is_file():
        if path.name in EXCLUDE_FILES:
            return True
        if path.suffix.lower() in EXCLUDE_SUFFIXES:
            return True

    return False


def print_tree(out, root_path: Path) -> None:
    out.write("STRUCTURE:\n")
    out.write(f"{root_path.name}/\n")

    for path in sorted(root_path.rglob("*")):
        if should_skip(path):
            continue

        rel = path.relative_to(root_path)
        depth = len(rel.parts) - 1
        indent = "  " * depth

        suffix = "/" if path.is_dir() else ""
        out.write(f"{indent}├── {path.name}{suffix}\n")

    out.write("\n\n")


def iter_source_files(root_path: Path):
    for p in sorted(root_path.rglob("*")):
        if not p.is_file():
            continue
        if should_skip(p):
            continue
        # include selected suffixes; also include files with no suffix but executable scripts if needed
        if p.suffix.lower() in INCLUDE_SUFFIXES:
            yield p


with output.open("w", encoding="utf-8") as out:
    print_tree(out, root)

    for p in iter_source_files(root):
        out.write(f"FILE: {p.relative_to(root)}\n")
        out.write("=" * 80 + "\n")
        try:
            out.write(p.read_text(encoding="utf-8"))
        except UnicodeDecodeError:
            out.write(p.read_text(encoding="latin-1", errors="replace"))
        out.write("\n\n")

print(f"Filtered directory tree + source files saved to {output}")


FILE: scripts/__init__.py
================================================================================


FILE: scripts/build_vision.sh
================================================================================
#!/usr/bin/env bash
set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT/vision"

rm -rf build
mkdir -p build
cd build

cmake ..
cmake --build . -j

echo "[OK] built: $ROOT/vision/bin/ght_face_eyes"


FILE: scripts/change_pin.py
================================================================================
import argparse
import time
import getpass

from src.config import load_config
from src.db import (
    connect,
    init_db,
    get_user_by_card,
    get_user_by_id,
    update_user_pin,
    is_locked,
    record_pin_failure,
    clear_auth_state,
)
from src.security import verify_pin, pbkdf2_hash_pin
from src.card import open_card


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--user-id", default=None)
    args = parser.parse_args()

    cfg = load_config("config.yaml")
    conn = connect(cfg.db_path)
    init_db(conn)

    if args.user_id:
        user = get_user_by_id(conn, args.user_id)
        if not user:
            raise SystemExit("unknown_user")
        card_id = user["card_id"]
    else:
        s = open_card(10)
        card_id = s.get_uid()
        if not card_id:
            raise SystemExit("no_card")
        user = get_user_by_card(conn, card_id)
        if not user:
            raise SystemExit("unknown_card")

    user_id = user["user_id"]
    now = int(time.time())
    locked, _ = is_locked(conn, user_id, now_epoch=now)
    if locked:
        raise SystemExit("locked_out")

    old_pin = getpass.getpass("Enter current PIN/mot de passe: ").strip()
    if not verify_pin(old_pin, user["pwd_salt"], user["pwd_hash"]):
        record_pin_failure(
            conn,
            user_id,
            now_epoch=now,
            max_attempts=cfg.auth.max_pin_attempts,
            lockout_seconds=cfg.auth.lockout_seconds,
        )
        raise SystemExit("bad_pin")

    new_pin1 = getpass.getpass("Enter new PIN/mot de passe: ").strip()
    new_pin2 = getpass.getpass("Confirm new PIN/mot de passe: ").strip()
    if not new_pin1 or new_pin1 != new_pin2:
        raise SystemExit("pin_mismatch")

    # Hash the new PIN and update the database
    salt, ph = pbkdf2_hash_pin(new_pin1)
    update_user_pin(conn, user_id, salt, ph)
    # Clear any recorded failures so the user isn't locked out after a successful change
    clear_auth_state(conn, user_id)

    print(f"PIN changed: user_id={user_id} card_id={card_id}")


if __name__ == "__main__":
    main()


FILE: scripts/demo_run.py
================================================================================
import getpass

from src.config import load_config
from src.db import connect, init_db
from src.auth_flow import run_auth_flow
from src.card import open_card


def main():
    cfg = load_config("config.yaml")
    conn = connect(cfg.db_path)
    init_db(conn)

    s = open_card(10)
    card_uid = s.get_uid()
    if not card_uid:
        print("[ACCESS DENIED] user=None bio_score=None reason=unknown_card")
        return

    rec = s.read_app_record()
    user_hash8 = rec.user_hash8 if rec else None
    tpl_hash8 = rec.tpl_hash8 if rec else None

    print(f"[DETECTED] card_id={card_uid} atr={s.atr_hex}")

    pin = getpass.getpass("Enter PIN/mot de passe: ").strip()


    result = run_auth_flow(
        cfg,
        conn,
        card_id=card_uid,
        card_atr=s.atr_hex,
        pin=pin,
        card_user_hash8=user_hash8,
        card_tpl_hash8=tpl_hash8,
    )

    if result.decision == "ALLOW":
        if result.bio_score is None:
            print(f"[ACCESS GRANTED] user={result.user_id} bio_score=None reason={result.reason}")
        else:
            print(f"[ACCESS GRANTED] user={result.user_id} bio_score={result.bio_score:.3f} reason={result.reason}")
    else:
        print(f"[ACCESS DENIED] user={result.user_id} bio_score={result.bio_score} reason={result.reason}")


if __name__ == "__main__":
    main()


FILE: scripts/enroll_user.py
================================================================================
import os
import time
import argparse
import cv2
import getpass

from src.config import load_config
from src.db import connect, init_db, upsert_user, upsert_biometric
from src.security import pbkdf2_hash_pin
from src.camera import CameraParams, capture_frame
from src.bio import sha256_file, compare_biometric
from src.card import open_card


def _cap(cfg):
    return capture_frame(
        CameraParams(
            index=cfg.camera.index,
            warmup_frames=cfg.camera.warmup_frames,
            width=cfg.camera.width,
            height=cfg.camera.height,
        )
    )


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--user-id", required=True)
    parser.add_argument("--max-attempts", type=int, default=12, help="Max capture attempts for a usable template")
    parser.add_argument("--sleep-ms", type=int, default=250, help="Sleep between attempts (ms)")
    parser.add_argument(
        "--min-score",
        type=float,
        default=None,
        help="Override biometric threshold for enrollment sanity check (default: cfg.biometric.score_threshold)",
    )
    args = parser.parse_args()

    cfg = load_config("config.yaml")
    conn = connect(cfg.db_path)
    init_db(conn)

    pin = getpass.getpass("Enter PIN/mot de passe: ").strip()
    if not pin:
        raise SystemExit("PIN empty")

    salt, ph = pbkdf2_hash_pin(pin)
    os.makedirs("data/templates", exist_ok=True)

    threshold = args.min_score if args.min_score is not None else cfg.biometric.score_threshold

    # Capture a template that can PASS a live-vs-template sanity check immediately.
    best = None  # (score, template_frame_bgr)
    for i in range(1, args.max_attempts + 1):
        tpl_frame = _cap(cfg)

        # Basic extractability check: frame vs itself should be high.
        self_score = compare_biometric(
            captured_bgr=tpl_frame,
            template_bgr=tpl_frame,
            use_face_crop=cfg.biometric.use_face_crop,
            nfeatures=cfg.biometric.orb_nfeatures,
        )

        if self_score < 0.5:
            print(f"[ENROLL] attempt={i}/{args.max_attempts} reject: self-extract failed self_score={self_score:.3f}")
            time.sleep(args.sleep_ms / 1000.0)
            continue

        # Immediate sanity check: capture another live frame and compare to candidate template frame.
        live_frame = _cap(cfg)
        score = compare_biometric(
            captured_bgr=live_frame,
            template_bgr=tpl_frame,
            use_face_crop=cfg.biometric.use_face_crop,
            nfeatures=cfg.biometric.orb_nfeatures,
        )

        print(f"[ENROLL] attempt={i}/{args.max_attempts} sanity_score={score:.3f} (threshold={threshold:.3f})")

        if best is None or score > best[0]:
            best = (score, tpl_frame)

        if score >= threshold:
            # Good enough: finalize
            template_path = f"data/templates/{args.user_id}.png"
            cv2.imwrite(template_path, tpl_frame)
            tpl_sha = sha256_file(template_path)

            s = open_card(10)
            card_uid, wrote = s.provision_or_load_uid(
                user_id=args.user_id,
                tpl_sha256_hex=tpl_sha,
            )

            print(f"[card] card_id={card_uid} atr={s.atr_hex}")
            print(f"[card] write_app_record={wrote}")

            upsert_user(conn, args.user_id, card_uid, salt, ph, card_atr=s.atr_hex)
            upsert_biometric(conn, args.user_id, template_path, tpl_sha, algo="ENROLL+SANITYCHECK")

            print(f"ENROLL OK: user_id={args.user_id}, template={template_path}, sanity_score={score:.3f}")
            return

        time.sleep(args.sleep_ms / 1000.0)

    # If we get here, enrollment failed to reach threshold.
    if best is not None:
        best_score, best_frame = best
        template_path = f"data/templates/{args.user_id}.png"
        cv2.imwrite(template_path, best_frame)
        print(f"[ENROLL] FAILED: could not reach threshold={threshold:.3f}. Best_score={best_score:.3f}")
        print(f"[ENROLL] Saved best-effort template to {template_path} for debugging.")
    raise SystemExit("enroll_failed_no_good_template")


if __name__ == "__main__":
    main()


FILE: scripts/init_db.py
================================================================================
from src.config import load_config
from src.db import connect, init_db

def main():
    cfg = load_config("config.yaml")
    conn = connect(cfg.db_path)
    init_db(conn)
    print(f"DB initialized: {cfg.db_path}")

if __name__ == "__main__":
    main()


FILE: scripts/probe_access.py
================================================================================
#!/usr/bin/env python3
from __future__ import annotations

import argparse
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

from src.card import open_card

from src.card import (
    CardError,
    VERIFY_TARGET_CSC0,
    VERIFY_TARGET_CSC1,
    VERIFY_TARGET_CSC2,
    ADDR_ISSUER_BASE,
    APP_WORD_BASE,
    APP_WORD_LEN,
)


CSC0_HEX = "00112233"
CSC1_HEX = "44556677"
CSC2_HEX = "89aabbcc"


def _parse_hex_code4(s: str) -> bytes:
    v = (s or "").strip().lower().replace("0x", "").replace(" ", "")
    b = bytes.fromhex(v)
    if len(b) != 4:
        raise ValueError("code4_must_be_4_bytes_hex")
    return b


def _candidate_codes() -> List[Tuple[str, bytes]]:
    out: List[Tuple[str, bytes]] = []
    for name, v in [("CSC0", CSC0_HEX), ("CSC1", CSC1_HEX), ("CSC2", CSC2_HEX)]:
        if v and v.strip():
            out.append((name, _parse_hex_code4(v)))
    return out


def _range_words(start: int, count: int) -> List[int]:
    return [start + i for i in range(count)]


def _fmt_addr(a: int) -> str:
    return f"0x{a:02X}"


def _safe_read_word(s, addr: int) -> Tuple[bool, Optional[bytes], Optional[str]]:
    try:
        data = s.read_word(addr)
        return True, data, None
    except Exception as e:
        return False, None, str(e)


def _safe_update_same_word(s, addr: int) -> Tuple[bool, Optional[str]]:
    ok, data, err = _safe_read_word(s, addr)
    if not ok or data is None:
        return False, f"read_failed_before_update: {err}"
    try:
        s.update_word(addr, data)
        return True, None
    except Exception as e:
        return False, str(e)


@dataclass
class VerifyOutcome:
    target_name: str
    target_p2: int
    ok: bool
    matched_source: Optional[str] = None
    sw_error: Optional[str] = None


def _try_verify_targets(s, codes: List[Tuple[str, bytes]]) -> List[VerifyOutcome]:
    targets = [
        ("CSC0", VERIFY_TARGET_CSC0),
        ("CSC1", VERIFY_TARGET_CSC1),
        ("CSC2", VERIFY_TARGET_CSC2),
    ]

    outcomes: List[VerifyOutcome] = []

    for name, p2 in targets:
        matched = None
        last_err = None
        for src_name, c in codes:
            try:
                s.verify(p2, c)
                matched = src_name
                last_err = None
                break
            except Exception as e:
                last_err = str(e)
                continue

        outcomes.append(
            VerifyOutcome(
                target_name=name,
                target_p2=p2,
                ok=(matched is not None),
                matched_source=matched,
                sw_error=None if matched is not None else last_err,
            )
        )
    return outcomes


def _print_block(title: str) -> None:
    print("\n" + "=" * 90)
    print(title)
    print("=" * 90)


def main() -> int:
    parser = argparse.ArgumentParser(description="Probe card access conditions (read/write/verify) for CartePuce")
    parser.add_argument("--timeout", type=int, default=10, help="Card wait timeout (seconds)")
    parser.add_argument(
        "--write-test",
        action="store_true",
        help="Perform UPDATE probes (update same data) to infer write permissions (sends UPDATE APDU).",
    )
    parser.add_argument(
        "--write-test-scope",
        choices=["app", "issuer", "range"],
        default="app",
        help="Which addresses to test UPDATE on: app(0x10..), issuer(0x01..), range(custom)",
    )
    parser.add_argument(
        "--range",
        default=None,
        help="Custom address range for probing, format: START:END (hex), e.g. 00:3F. Used for read scan; also for write-test-scope=range.",
    )
    args = parser.parse_args()

    try:
        s = open_card(args.timeout)
    except Exception as e:
        print(f"[ERROR] cannot open card: {e}")
        return 2

    _print_block("CARD BASIC INFO")
    print(f"ATR: {s.atr_hex}")

    issuer_addrs = _range_words(ADDR_ISSUER_BASE, 4)
    print(f"ISSUER_SN addresses: {_fmt_addr(issuer_addrs[0])}..{_fmt_addr(issuer_addrs[-1])}")

    if args.range:
        try:
            a, b = args.range.split(":")
            start = int(a, 16)
            end = int(b, 16)
            if not (0 <= start <= 0xFF and 0 <= end <= 0xFF and start <= end):
                raise ValueError("range_out_of_bounds")
        except Exception as e:
            raise SystemExit(f"bad --range '{args.range}': {e}")
        scan_addrs = list(range(start, end + 1))
        scan_label = f"custom_range({_fmt_addr(start)}..{_fmt_addr(end)})"
    else:
        scan_addrs = sorted(set(issuer_addrs + _range_words(APP_WORD_BASE, APP_WORD_LEN)))
        scan_label = "default(issuer + app_record)"

    _print_block(f"READ PROBE: {scan_label}")
    read_ok: List[int] = []
    read_fail: List[int] = []
    for addr in scan_addrs:
        ok, data, err = _safe_read_word(s, addr)
        if ok and data is not None:
            read_ok.append(addr)
            print(f"[READ OK ] addr={_fmt_addr(addr)} data={data.hex()}")
        else:
            read_fail.append(addr)
            print(f"[READ DENY] addr={_fmt_addr(addr)} err={err}")

    codes = _candidate_codes()

    _print_block("VERIFY PROBE (CSC0/CSC1/CSC2)")
    if not codes:
        print("No CSC codes configured in code.")
        return 1

    outcomes = _try_verify_targets(s, codes)

    verified: Dict[str, bool] = {}
    for o in outcomes:
        verified[o.target_name] = o.ok
        if o.ok:
            print(f"[VERIFY OK ] target={o.target_name} P2=0x{o.target_p2:02X} matched={o.matched_source}")
        else:
            print(f"[VERIFY NO ] target={o.target_name} P2=0x{o.target_p2:02X} err={o.sw_error}")

    if args.write_test:
        _print_block("WRITE PROBE (UPDATE same-word)")

        if args.write_test_scope == "app":
            w_addrs = _range_words(APP_WORD_BASE, APP_WORD_LEN)
            w_label = f"app_record({_fmt_addr(w_addrs[0])}..{_fmt_addr(w_addrs[-1])})"
        elif args.write_test_scope == "issuer":
            w_addrs = issuer_addrs
            w_label = f"issuer_sn({_fmt_addr(w_addrs[0])}..{_fmt_addr(w_addrs[-1])})"
        else:
            if not args.range:
                raise SystemExit("write-test-scope=range requires --range START:END")
            w_addrs = scan_addrs
            w_label = f"custom_range({_fmt_addr(w_addrs[0])}..{_fmt_addr(w_addrs[-1])})"

        print(f"Scope: {w_label}")

        print("Phase 1: UPDATE with current session state")
        for addr in w_addrs:
            ok, err = _safe_update_same_word(s, addr)
            if ok:
                print(f"[UPD OK ] addr={_fmt_addr(addr)}")
            else:
                print(f"[UPD NO ] addr={_fmt_addr(addr)} err={err}")

        _print_block("WRITE PROBE Phase 2: unlock (CSC1 -> CSC0 -> CSC2) then UPDATE again")
        unlock_targets = [("CSC1", VERIFY_TARGET_CSC1), ("CSC0", VERIFY_TARGET_CSC0), ("CSC2", VERIFY_TARGET_CSC2)]
        unlocked = False
        last_err = None
        for name, p2 in unlock_targets:
            for src_name, c in codes:
                try:
                    s.verify(p2, c)
                    print(f"[UNLOCK OK] via {name} (P2=0x{p2:02X}) using {src_name}")
                    unlocked = True
                    break
                except Exception as e:
                    last_err = str(e)
            if unlocked:
                break

        if not unlocked:
            print(f"[UNLOCK NO] last_err={last_err}")
        else:
            for addr in w_addrs:
                ok, err = _safe_update_same_word(s, addr)
                if ok:
                    print(f"[UPD OK ] addr={_fmt_addr(addr)}")
                else:
                    print(f"[UPD NO ] addr={_fmt_addr(addr)} err={err}")

    _print_block("INFERENCE SUMMARY (best-effort)")
    print("Named regions (based on current project address usage):")
    print(f"  - ISSUER_SN: {_fmt_addr(ADDR_ISSUER_BASE)}..{_fmt_addr(ADDR_ISSUER_BASE+3)}")
    print(f"  - APP_RECORD: {_fmt_addr(APP_WORD_BASE)}..{_fmt_addr(APP_WORD_BASE+APP_WORD_LEN-1)}")

    issuer_can_read = all(a in read_ok for a in issuer_addrs)
    app_can_read = all(a in read_ok for a in _range_words(APP_WORD_BASE, APP_WORD_LEN))

    print("\nObserved READ capability in this run:")
    print(f"  - ISSUER_SN readable: {issuer_can_read}")
    print(f"  - APP_RECORD readable: {app_can_read}")

    print("\nObserved VERIFY capability in this run:")
    for k in ["CSC0", "CSC1", "CSC2"]:
        print(f"  - {k}: {verified.get(k, False)}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())


FILE: scripts/recover_pin.py
================================================================================
import hashlib
import getpass
import cv2

from src.config import load_config
from src.db import (
    connect,
    init_db,
    get_user_by_card,
    update_user_pin,
    clear_auth_state,
    log_auth,
)
from src.security import pbkdf2_hash_pin, verify_file_sha256
from src.camera import CameraParams, capture_frame
from src.bio import compare_biometric
from src.card import open_card


def _sha256_8_hex(s: str) -> str:
    return hashlib.sha256(s.encode("utf-8")).digest()[:8].hex()


def _tpl_hash8_from_sha256_hex(sha256_hex: str):
    if not sha256_hex or len(sha256_hex) != 64:
        return None
    return bytes.fromhex(sha256_hex)[:8].hex()


def main():
    cfg = load_config("config.yaml")
    conn = connect(cfg.db_path)
    init_db(conn)

    s = open_card(10)
    card_id = s.get_uid()
    if not card_id:
        raise SystemExit("no_card")

    rec = s.read_app_record()
    if not rec:
        log_auth(conn, card_id, s.atr_hex, None, False, None, "DENY", "card_binding_missing")
        raise SystemExit("card_binding_missing")

    user = get_user_by_card(conn, card_id)
    if not user:
        log_auth(conn, card_id, s.atr_hex, None, False, None, "DENY", "unknown_card")
        raise SystemExit("unknown_card")

    user_id = user["user_id"]
    template_path = user.get("template_path")
    template_sha256 = user.get("template_sha256")

    if cfg.auth.enforce_template_integrity:
        if not verify_file_sha256(template_path, template_sha256):
            log_auth(conn, card_id, s.atr_hex, user_id, False, None, "DENY", "template_tampered")
            raise SystemExit("template_tampered")

    if cfg.auth.enforce_card_binding:
        if rec.user_hash8.lower() != _sha256_8_hex(user_id):
            raise SystemExit("card_user_binding_mismatch")
        if rec.tpl_hash8.lower() != _tpl_hash8_from_sha256_hex(template_sha256):
            raise SystemExit("card_template_binding_mismatch")

    frame = capture_frame(CameraParams(
        index=cfg.camera.index,
        warmup_frames=cfg.camera.warmup_frames,
        width=cfg.camera.width,
        height=cfg.camera.height,
    ))

    template = cv2.imread(template_path)
    score = compare_biometric(
        captured_bgr=frame,
        template_bgr=template,
        use_face_crop=cfg.biometric.use_face_crop,
        nfeatures=cfg.biometric.orb_nfeatures,
    )

    if score < cfg.biometric.score_threshold:
        raise SystemExit("biometric_mismatch")

    new_pin1 = getpass.getpass("Enter new PIN/mot de passe: ").strip()
    new_pin2 = getpass.getpass("Re-enter new PIN/mot de passe: ").strip()
    if not new_pin1 or new_pin1 != new_pin2:
        raise SystemExit("pin_mismatch")

    salt, ph = pbkdf2_hash_pin(new_pin1)
    update_user_pin(conn, user_id, salt, ph)
    clear_auth_state(conn, user_id)

    log_auth(conn, card_id, s.atr_hex, user_id, True, score, "ALLOW", "pin_recovered")
    print(f"PIN recovered: user_id={user_id} card_id={card_id} bio_score={score:.3f}")


if __name__ == "__main__":
    main()


FILE: scripts/security_demo.py
================================================================================
#!/usr/bin/env python3
from __future__ import annotations

import argparse
import os
import sqlite3
import sys
import time

from src.config import load_config
from src.db import connect, init_db, upsert_user, upsert_biometric, log_auth, get_user_by_card
from src.security import (
    pbkdf2_hash_pin,
    verify_pin,
    NonceReplayProtector,
    generate_nonce,
    new_card_key,
    key_id_from_key,
    build_hmac_message,
    compute_hmac_tag,
    verify_hmac_tag,
    sha256_file_hex,
    verify_file_sha256,
    build_audit_context,
    encode_audit_context,
    compact_reason,
)


def _print(title: str) -> None:
    print("\n" + "=" * 80)
    print(title)
    print("=" * 80)


def _ensure_template(path: str) -> None:
    if os.path.exists(path):
        return
    os.makedirs(os.path.dirname(path), exist_ok=True)
    # Create a deterministic dummy template file (not an actual face)
    with open(path, "wb") as f:
        f.write(b"DEMO_TEMPLATE_V1\n" + b"\x00" * 1024)


def demo_password_hashing() -> None:
    _print("1) Password hashing demo (PBKDF2 + optional pepper compatibility)")

    pin = "1234"
    salt, h = pbkdf2_hash_pin(pin)
    ok = verify_pin(pin, salt, h)
    bad = verify_pin("9999", salt, h)
    print(f"verify_pin(correct) = {ok} (expected True)")
    print(f"verify_pin(wrong)   = {bad} (expected False)")

    print("\n[pepper] If you set CARTEPUCE_PASSWORD_PEPPER and re-run, verify_pin remains backward-compatible.")
    print("Example:")
    print('  export CARTEPUCE_PASSWORD_PEPPER="my-pepper"')
    print("  python3 scripts/security_demo.py --only password")


def demo_template_integrity(tmp_path: str) -> None:
    _print("2) Template integrity demo (detect template replacement)")

    _ensure_template(tmp_path)
    expected = sha256_file_hex(tmp_path)
    ok = verify_file_sha256(tmp_path, expected)
    print(f"verify_file_sha256(original) = {ok} (expected True)")

    # Tamper file
    with open(tmp_path, "ab") as f:
        f.write(b"\nTAMPER\n")

    bad = verify_file_sha256(tmp_path, expected)
    print(f"verify_file_sha256(tampered)  = {bad} (expected False)")


def demo_replay_protection(card_id: str) -> None:
    _print("3) Replay protection demo (nonce re-use detection)")

    rp = NonceReplayProtector(ttl_seconds=30, max_entries=128)
    nonce = generate_nonce(16)

    d1 = rp.check_and_remember(card_id, nonce)
    d2 = rp.check_and_remember(card_id, nonce)  # replay immediately
    print(f"first use : ok={d1.ok}, reason={d1.reason} (expected ok)")
    print(f"replay    : ok={d2.ok}, reason={d2.reason} (expected replay_nonce_seen)")

    print("\n(wait TTL expiration demo)")
    time.sleep(2)
    print("You can re-run with shorter TTL to show expiry behavior if needed.")


def demo_hmac_challenge_response(card_id: str) -> None:
    _print("4) HMAC challenge-response demo (host-side secret, constant-time verify)")

    k_card = new_card_key(32)
    key_id = key_id_from_key(k_card)
    nonce = generate_nonce(16)
    counter = 1
    context = "demo-login@terminal-1"

    msg = build_hmac_message(card_id, nonce, counter, context)
    tag = compute_hmac_tag(k_card, msg, tag_len=16)

    ok = verify_hmac_tag(k_card, msg, tag)
    print(f"key_id={key_id}")
    print(f"tag(ok)={ok} (expected True)")

    # Attack: modify nonce or context
    msg2 = build_hmac_message(card_id, generate_nonce(16), counter, context)
    bad = verify_hmac_tag(k_card, msg2, tag)
    print(f"tag(after message change)={bad} (expected False)")

    # Show audit context packing
    ctx = build_audit_context(nonce=nonce, counter=counter, key_id=key_id, tag=tag, context=context)
    ctx_json = encode_audit_context(ctx)
    reason = compact_reason("hmac_demo", ctx_json)
    print(f"audit_reason_field_example:\n  {reason}")


def demo_auth_logs(db_path: str) -> None:
    _print("5) Audit log demo (write synthetic auth logs + query)")

    conn = connect(db_path)
    init_db(conn)

    # synthetic log entries
    log_auth(conn, "deadbeef" * 4, "3B 02 53 01", "alice", True, 0.42, "ALLOW", "ok")
    log_auth(conn, "deadbeef" * 4, "3B 02 53 01", "alice", False, None, "DENY", "bad_pin")

    rows = conn.execute(
        "SELECT ts, card_id, user_id, pwd_ok, bio_score, decision, reason FROM auth_logs ORDER BY id DESC LIMIT 5"
    ).fetchall()
    for r in rows:
        print(dict(r))


def demo_db_offline_attack_model(db_path: str) -> None:
    _print("6) DB compromise model demo (offline guessing cost + pepper)")

    print("This demo explains the threat model rather than brute-forcing.")
    print("- pwd_hash is PBKDF2-HMAC-SHA256 with 200k iterations (costly offline).")
    print("- If CARTEPUCE_PASSWORD_PEPPER is set, DB-only compromise is insufficient to verify guesses.")
    print(f"DB path: {db_path}")
    print("Check your users table stores only salt/hash, not plaintext.")


def main() -> int:
    parser = argparse.ArgumentParser(description="Security demo runner for CartePuce project")
    parser.add_argument("--config", default="config.yaml", help="Config path")
    parser.add_argument("--template", default="data/templates/demo_template.bin", help="Template file for integrity demo")
    parser.add_argument("--card-id", default="f22c9c89dce6ca8876dcc20421af84d3", help="Demo card_id (16B hex -> 32 chars)")
    parser.add_argument(
        "--only",
        choices=["password", "template", "replay", "hmac", "logs", "dbmodel", "all"],
        default="all",
        help="Run only one section",
    )
    args = parser.parse_args()

    cfg = load_config(args.config)

    if args.only in ("password", "all"):
        demo_password_hashing()

    if args.only in ("template", "all"):
        demo_template_integrity(args.template)

    if args.only in ("replay", "all"):
        demo_replay_protection(args.card_id)

    if args.only in ("hmac", "all"):
        demo_hmac_challenge_response(args.card_id)

    if args.only in ("logs", "all"):
        demo_auth_logs(cfg.db_path)

    if args.only in ("dbmodel", "all"):
        demo_db_offline_attack_model(cfg.db_path)

    print("\nDONE")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())


FILE: scripts/test_camera.py
================================================================================
import cv2
from src.config import load_config
from src.camera import CameraParams, capture_frame

def main():
    cfg = load_config("config.yaml")
    frame = capture_frame(CameraParams(
        index=cfg.camera.index,
        warmup_frames=cfg.camera.warmup_frames,
        width=cfg.camera.width,
        height=cfg.camera.height,
    ))
    cv2.imwrite("data/camera_test.png", frame)
    print("OK: saved data/camera_test.png")

if __name__ == "__main__":
    main()


FILE: scripts/test_card.py
================================================================================
import argparse
from typing import Optional

from src.card import CardSession


def _print_app_record(r) -> None:
    if r is None:
        print("app_record: None")
        return
    print("app_record:")
    print(f"  card_uid  = {r.card_uid}")
    print(f"  user_hash8 = {r.user_hash8}")
    print(f"  tpl_hash8  = {r.tpl_hash8}")


def main():
    parser = argparse.ArgumentParser(description="Print detailed card information")
    parser.add_argument("--timeout", type=int, default=30, help="Timeout seconds when waiting for a card")
    parser.add_argument("--simulate-card-id", dest="sim_card_id", help="Simulated card_id (for offline testing)")
    parser.add_argument("--simulate-atr", dest="sim_atr", help="Simulated ATR hex string (for offline testing)")
    args = parser.parse_args()

    # If simulation args are provided, print them and exit
    if args.sim_card_id or args.sim_atr:
        print("Simulated card info:")
        print(f"  card_id = {args.sim_card_id}")
        print(f"  atr_hex = {args.sim_atr}")
        return

    try:
        s = CardSession(timeout_seconds=args.timeout)
    except Exception as e:
        print(f"No card found or error: {e}")
        return

    # ATR
    print(f"ATR: {s.atr_hex}")

    # Issuer SN
    try:
        issuer = s.get_issuer_sn()
        print(f"Issuer SN (raw): {issuer.hex()}")
    except Exception as e:
        print(f"Could not read issuer SN: {e}")

    # UID derived from issuer
    try:
        uid_from_issuer = s.uid_from_issuer()
        print(f"UID from issuer: {uid_from_issuer}")
    except Exception as e:
        print(f"Could not compute uid from issuer: {e}")

    # Stored app record UID
    card_id = s.get_uid()
    print(f"Stored card_id (app record): {card_id}")

    # App record details
    try:
        app = s.read_app_record()
        _print_app_record(app)
    except Exception as e:
        print(f"Could not read app record: {e}")

    parser = argparse.ArgumentParser(description="Print detailed card information")
    parser.add_argument("--timeout", type=int, default=30, help="Timeout seconds when waiting for a card")
    parser.add_argument("--simulate-card-id", dest="sim_card_id", help="Simulated card_id (for offline testing)")
    parser.add_argument("--simulate-atr", dest="sim_atr", help="Simulated ATR hex string (for offline testing)")
    args = parser.parse_args()

    # If simulation args are provided, print them and exit
    if args.sim_card_id or args.sim_atr:
        print("Simulated card info:")
        print(f"  card_id = {args.sim_card_id}")
        print(f"  atr_hex = {args.sim_atr}")
        return

    try:
        s = CardSession(timeout_seconds=args.timeout)
    except Exception as e:
        print(f"No card found or error: {e}")
        return

    # ATR
    print(f"ATR: {s.atr_hex}")

    # Issuer SN
    try:
        issuer = s.get_issuer_sn()
        print(f"Issuer SN (raw): {issuer.hex()}")
    except Exception as e:
        print(f"Could not read issuer SN: {e}")

    # UID derived from issuer
    try:
        uid_from_issuer = s.uid_from_issuer()
        print(f"UID from issuer: {uid_from_issuer}")
    except Exception as e:
        print(f"Could not compute uid from issuer: {e}")

    # Stored app record UID
    card_id = s.get_uid()
    print(f"Stored card_id (app record): {card_id}")

    # App record details
    try:
        app = s.read_app_record()
        _print_app_record(app)
    except Exception as e:
        print(f"Could not read app record: {e}")


if __name__ == "__main__":
    main()


FILE: scripts/test_vision.py
================================================================================
import argparse
import cv2

from src.config import load_config
from src.camera import CameraParams, capture_frame
from src.bio import compare_biometric


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--template", default=None, help="Template image path to compare against live capture")
    args = parser.parse_args()

    cfg = load_config("config.yaml")

    frame = capture_frame(CameraParams(
        index=cfg.camera.index,
        warmup_frames=cfg.camera.warmup_frames,
        width=cfg.camera.width,
        height=cfg.camera.height,
    ))

    cv2.imwrite("data/vision_test.png", frame)
    print("saved data/vision_test.png")

    if args.template:
        tpl = cv2.imread(args.template)
        if tpl is None:
            raise SystemExit(f"cannot_read_template:{args.template}")

        score = compare_biometric(
            captured_bgr=frame,
            template_bgr=tpl,
            use_face_crop=cfg.biometric.use_face_crop,
            nfeatures=cfg.biometric.orb_nfeatures,
        )
        print(f"live_vs_template score={score:.3f} template={args.template}")
    else:
        score = compare_biometric(frame, frame)
        print(f"self-compare score={score:.3f}")


if __name__ == "__main__":
    main()


FILE: src/__init__.py
================================================================================


FILE: src/auth_flow.py
================================================================================
from __future__ import annotations

import os
import time
import hashlib
import cv2
from dataclasses import dataclass
from typing import Optional

from .config import AppConfig
from .db import get_user_by_card, log_auth, is_locked, record_pin_failure, clear_auth_state
from .security import verify_pin, verify_file_sha256, build_audit_context, encode_audit_context, compact_reason
from .camera import CameraParams, capture_frame
from .bio import compare_biometric


@dataclass
class AuthResult:
    decision: str
    reason: str
    user_id: Optional[str] = None
    bio_score: Optional[float] = None


def _sha256_8_hex(s: str) -> str:
    return hashlib.sha256(s.encode("utf-8")).digest()[:8].hex()


def _tpl_hash8_from_sha256_hex(sha256_hex: str) -> Optional[str]:
    h = (sha256_hex or "").strip().lower()
    if len(h) != 64:
        return None
    try:
        return bytes.fromhex(h)[:8].hex()
    except ValueError:
        return None


def _ctx(**kwargs):
    return encode_audit_context(build_audit_context(extra=kwargs))


def run_auth_flow(
    cfg: AppConfig,
    conn,
    card_id: str,
    pin: str,
    card_atr: Optional[str] = None,
    card_user_hash8: Optional[str] = None,
    card_tpl_hash8: Optional[str] = None,
) -> AuthResult:
    user = get_user_by_card(conn, card_id)
    if not user:
        log_auth(conn, card_id, card_atr, None, False, None, "DENY", compact_reason("unknown_card", _ctx(card_id=card_id)))
        return AuthResult(decision="DENY", reason="unknown_card")

    user_id = user["user_id"]

    now_epoch = int(time.time())
    locked, locked_until = is_locked(conn, user_id, now_epoch=now_epoch)
    if locked:
        log_auth(conn, card_id, card_atr, user_id, False, None, "DENY", compact_reason("locked_out", _ctx(card_id=card_id, user_id=user_id, locked_until_epoch=locked_until)))
        return AuthResult(decision="DENY", reason="locked_out", user_id=user_id)

    template_path = user.get("template_path")
    template_sha256 = user.get("template_sha256")

    if cfg.auth.enforce_template_integrity:
        if not template_path or not template_sha256:
            log_auth(conn, card_id, card_atr, user_id, False, None, "DENY", compact_reason("no_biometric_template", _ctx(card_id=card_id, user_id=user_id)))
            return AuthResult(decision="DENY", reason="no_biometric_template", user_id=user_id)

        if not verify_file_sha256(template_path, template_sha256):
            log_auth(conn, card_id, card_atr, user_id, False, None, "DENY", compact_reason("template_tampered", _ctx(card_id=card_id, user_id=user_id, template_path=template_path)))
            return AuthResult(decision="DENY", reason="template_tampered", user_id=user_id)

    if cfg.auth.enforce_card_binding:
        if not card_user_hash8 or not card_tpl_hash8:
            log_auth(conn, card_id, card_atr, user_id, False, None, "DENY", compact_reason("card_binding_missing", _ctx(card_id=card_id, user_id=user_id)))
            return AuthResult(decision="DENY", reason="card_binding_missing", user_id=user_id)

        expected_user_hash8 = _sha256_8_hex(user_id)
        expected_tpl_hash8 = _tpl_hash8_from_sha256_hex(template_sha256) if template_sha256 else None

        cu = (card_user_hash8 or "").strip().lower()
        ct = (card_tpl_hash8 or "").strip().lower()

        if cu != expected_user_hash8:
            log_auth(conn, card_id, card_atr, user_id, False, None, "DENY", compact_reason("card_user_binding_mismatch", _ctx(card_id=card_id, user_id=user_id, expected=expected_user_hash8, got=cu)))
            return AuthResult(decision="DENY", reason="card_user_binding_mismatch", user_id=user_id)

        if expected_tpl_hash8 is None or ct != expected_tpl_hash8:
            log_auth(conn, card_id, card_atr, user_id, False, None, "DENY", compact_reason("card_template_binding_mismatch", _ctx(card_id=card_id, user_id=user_id, expected=expected_tpl_hash8, got=ct)))
            return AuthResult(decision="DENY", reason="card_template_binding_mismatch", user_id=user_id)

    pwd_ok = verify_pin(pin, user["pwd_salt"], user["pwd_hash"])
    if not pwd_ok:
        st = record_pin_failure(conn, user_id, now_epoch=now_epoch, max_attempts=cfg.auth.max_pin_attempts, lockout_seconds=cfg.auth.lockout_seconds)
        if st.get("locked_until_epoch") and int(st["locked_until_epoch"]) > now_epoch:
            log_auth(conn, card_id, card_atr, user_id, False, None, "DENY", compact_reason("locked_out", _ctx(card_id=card_id, user_id=user_id, locked_until_epoch=st["locked_until_epoch"], fail_count=st["fail_count"])))
            return AuthResult(decision="DENY", reason="locked_out", user_id=user_id)
        log_auth(conn, card_id, card_atr, user_id, False, None, "DENY", compact_reason("bad_pin", _ctx(card_id=card_id, user_id=user_id, fail_count=st["fail_count"])))
        return AuthResult(decision="DENY", reason="bad_pin", user_id=user_id)

    clear_auth_state(conn, user_id)

    if int(cfg.auth.required_factors) <= 2:
        log_auth(conn, card_id, card_atr, user_id, True, None, "ALLOW", compact_reason("ok_2fa", _ctx(card_id=card_id, user_id=user_id)))
        return AuthResult(decision="ALLOW", reason="ok_2fa", user_id=user_id, bio_score=None)

    frame = capture_frame(CameraParams(
        index=cfg.camera.index,
        warmup_frames=cfg.camera.warmup_frames,
        width=cfg.camera.width,
        height=cfg.camera.height,
    ))

    if template_path and os.path.exists(template_path):
        template = cv2.imread(template_path)
    else:
        template = None

    if template is None:
        log_auth(conn, card_id, card_atr, user_id, True, None, "DENY", compact_reason("template_read_error", _ctx(card_id=card_id, user_id=user_id, template_path=template_path)))
        return AuthResult(decision="DENY", reason="template_read_error", user_id=user_id)

    score = compare_biometric(
        captured_bgr=frame,
        template_bgr=template,
        use_face_crop=cfg.biometric.use_face_crop,
        nfeatures=cfg.biometric.orb_nfeatures,
    )

    if score >= cfg.biometric.score_threshold:
        log_auth(conn, card_id, card_atr, user_id, True, score, "ALLOW", compact_reason("ok", _ctx(card_id=card_id, user_id=user_id, bio_score=score)))
        return AuthResult(decision="ALLOW", reason="ok", user_id=user_id, bio_score=score)

    log_auth(conn, card_id, card_atr, user_id, True, score, "DENY", compact_reason("biometric_mismatch", _ctx(card_id=card_id, user_id=user_id, bio_score=score)))
    return AuthResult(decision="DENY", reason="biometric_mismatch", user_id=user_id, bio_score=score)


FILE: src/bio.py
================================================================================
# FILE: src/bio.py
from __future__ import annotations

import hashlib
import os
import tempfile
from dataclasses import dataclass
from typing import Optional, Tuple, Dict, Any

import cv2
import numpy as np

from .vision_backend import detect_face_eyes_by_ght


def sha256_file(path: str) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()


def _clamp_roi(x0: int, y0: int, x1: int, y1: int, w: int, h: int) -> Tuple[int, int, int, int]:
    x0 = max(0, min(x0, w))
    x1 = max(0, min(x1, w))
    y0 = max(0, min(y0, h))
    y1 = max(0, min(y1, h))
    if x1 < x0:
        x0, x1 = x1, x0
    if y1 < y0:
        y0, y1 = y1, y0
    return x0, y0, x1, y1


# -----------------------------
# Eye-based signature (H+S hist)
# -----------------------------
def _eye_roi_from_eye(bgr: np.ndarray, eye: Tuple[int, int], r: int) -> Optional[np.ndarray]:
    if bgr is None or eye is None or r is None:
        return None
    h, w = bgr.shape[:2]
    ex, ey = int(eye[0]), int(eye[1])

    rr = max(10, int(round(r * 1.20)))  # slightly larger to reduce bbox jitter sensitivity
    x0, y0, x1, y1 = _clamp_roi(ex - rr, ey - rr, ex + rr, ey + rr, w, h)
    if (x1 - x0) < 24 or (y1 - y0) < 24:
        return None
    return bgr[y0:y1, x0:x1]


def _hs_signature(eye_bgr: np.ndarray, h_bins: int = 24, s_bins: int = 24) -> np.ndarray:
    hsv = cv2.cvtColor(eye_bgr, cv2.COLOR_BGR2HSV)

    # Use only H and S to reduce sensitivity to illumination (V).
    hs = hsv[:, :, :2]

    hist = cv2.calcHist([hs], [0, 1], None, [h_bins, s_bins], [0, 180, 0, 256])
    hist = hist.astype(np.float32).flatten()

    s = float(np.sum(hist))
    if s > 0:
        hist /= s
    return hist


def _corr_similarity(a: np.ndarray, b: np.ndarray) -> float:
    """
    Correlation in [-1,1] mapped to [0,1].
    """
    a = a.astype(np.float32)
    b = b.astype(np.float32)
    corr = float(cv2.compareHist(a, b, cv2.HISTCMP_CORREL))
    # numeric safety
    if corr < -1.0:
        corr = -1.0
    if corr > 1.0:
        corr = 1.0
    return 0.5 * (corr + 1.0)


# -----------------------------
# Face-based fallback (LBP hist)
# -----------------------------
def _lbp8u(gray: np.ndarray) -> np.ndarray:
    """
    Basic LBP (8 neighbors, radius=1) returning uint8 codes.
    """
    g = gray
    h, w = g.shape
    lbp = np.zeros((h - 2, w - 2), dtype=np.uint8)
    c = g[1:-1, 1:-1]

    lbp |= ((g[0:-2, 0:-2] >= c) << 7).astype(np.uint8)
    lbp |= ((g[0:-2, 1:-1] >= c) << 6).astype(np.uint8)
    lbp |= ((g[0:-2, 2:  ] >= c) << 5).astype(np.uint8)
    lbp |= ((g[1:-1, 2:  ] >= c) << 4).astype(np.uint8)
    lbp |= ((g[2:  , 2:  ] >= c) << 3).astype(np.uint8)
    lbp |= ((g[2:  , 1:-1] >= c) << 2).astype(np.uint8)
    lbp |= ((g[2:  , 0:-2] >= c) << 1).astype(np.uint8)
    lbp |= ((g[1:-1, 0:-2] >= c) << 0).astype(np.uint8)

    return lbp


def _face_signature_lbp(face_bgr: np.ndarray) -> np.ndarray:
    gray = cv2.cvtColor(face_bgr, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    gray = cv2.resize(gray, (160, 160), interpolation=cv2.INTER_AREA)

    lbp = _lbp8u(gray)
    hist = cv2.calcHist([lbp], [0], None, [256], [0, 256]).astype(np.float32).flatten()
    s = float(np.sum(hist))
    if s > 0:
        hist /= s
    return hist


def _detect_face_haar(image_bgr: np.ndarray) -> Optional[Tuple[int, int, int, int]]:
    face_path = os.path.join(cv2.data.haarcascades, "haarcascade_frontalface_default.xml")
    face_cas = cv2.CascadeClassifier(face_path)
    if face_cas.empty():
        return None

    gray = cv2.cvtColor(image_bgr, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)

    faces = face_cas.detectMultiScale(
        gray,
        scaleFactor=1.1,
        minNeighbors=5,
        flags=cv2.CASCADE_SCALE_IMAGE,
        minSize=(80, 80),
    )
    if faces is None or len(faces) == 0:
        return None

    x, y, w, h = sorted(faces, key=lambda t: t[2] * t[3], reverse=True)[0]
    return int(x), int(y), int(w), int(h)


@dataclass
class EyeGeom:
    eye1: Tuple[int, int]
    eye2: Tuple[int, int]
    r: int
    method: str
    debug: str = ""


def _detect_eyes_fallback_haar(image_bgr: np.ndarray) -> Optional[EyeGeom]:
    face_box = _detect_face_haar(image_bgr)
    if face_box is None:
        return None
    x, y, w, h = face_box

    eye_path = os.path.join(cv2.data.haarcascades, "haarcascade_eye.xml")
    eye_cas = cv2.CascadeClassifier(eye_path)
    if eye_cas.empty():
        return None

    gray = cv2.cvtColor(image_bgr, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)
    face_gray = gray[y:y+h, x:x+w]

    eyes = eye_cas.detectMultiScale(
        face_gray,
        scaleFactor=1.1,
        minNeighbors=8,
        flags=cv2.CASCADE_SCALE_IMAGE,
        minSize=(18, 18),
        maxSize=(max(20, w // 2), max(20, h // 2)),
    )
    if eyes is None or len(eyes) < 2:
        return None

    cand = []
    for (ex, ey, ew, eh) in eyes:
        cy = ey + eh / 2.0
        if cy > 0.65 * h:
            continue
        cand.append((ex, ey, ew, eh))
    if len(cand) < 2:
        cand = list(eyes)

    cand = sorted(cand, key=lambda t: t[2] * t[3], reverse=True)[:2]
    if len(cand) < 2:
        return None

    (ex1, ey1, ew1, eh1), (ex2, ey2, ew2, eh2) = cand
    c1 = (int(x + ex1 + ew1 / 2), int(y + ey1 + eh1 / 2))
    c2 = (int(x + ex2 + ew2 / 2), int(y + ey2 + eh2 / 2))
    if c2[0] < c1[0]:
        c1, c2 = c2, c1
        ew1, eh1, ew2, eh2 = ew2, eh2, ew1, eh1

    approx_r = int(round(0.30 * min(ew1, eh1, ew2, eh2)))
    approx_r = max(10, min(approx_r, 28))

    return EyeGeom(eye1=c1, eye2=c2, r=approx_r, method="haar", debug=f"face={face_box} eyes={cand} r={approx_r}")


def _detect_eyes_primary_ght(image_bgr: np.ndarray) -> Tuple[Optional[EyeGeom], str]:
    with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tf:
        tmp_path = tf.name
    try:
        cv2.imwrite(tmp_path, image_bgr)
        det = detect_face_eyes_by_ght(tmp_path, headless=True)
    finally:
        try:
            os.remove(tmp_path)
        except Exception:
            pass

    if not det.eyes_ok or det.eye1 is None or det.eye2 is None or det.eye_r is None:
        return None, f"ght_eyes_not_found:{det.raw}"

    return EyeGeom(eye1=det.eye1, eye2=det.eye2, r=int(det.eye_r), method="ght", debug="ok"), "ok"


def _extract_eye_signature(image_bgr: np.ndarray) -> Tuple[Optional[np.ndarray], str]:
    eg, reason = _detect_eyes_primary_ght(image_bgr)
    if eg is None:
        eg = _detect_eyes_fallback_haar(image_bgr)
        if eg is None:
            return None, f"eyes_not_found:{reason}"
    # build signature from both eyes
    roi1 = _eye_roi_from_eye(image_bgr, eg.eye1, eg.r)
    roi2 = _eye_roi_from_eye(image_bgr, eg.eye2, eg.r)
    if roi1 is None or roi2 is None:
        return None, f"eye_roi_failed:{eg.method}:{eg.debug}"

    s1 = _hs_signature(roi1)
    s2 = _hs_signature(roi2)
    sig = 0.5 * (s1 + s2)
    z = float(np.sum(sig))
    if z > 0:
        sig /= z
    return sig, f"ok:eye:{eg.method}"


def _extract_face_signature(image_bgr: np.ndarray) -> Tuple[Optional[np.ndarray], str]:
    face_box = _detect_face_haar(image_bgr)
    if face_box is None:
        return None, "face_not_found"
    x, y, w, h = face_box

    # crop with small margin
    mx = int(round(0.08 * w))
    my = int(round(0.10 * h))
    x0, y0, x1, y1 = _clamp_roi(x - mx, y - my, x + w + mx, y + h + my, image_bgr.shape[1], image_bgr.shape[0])
    face = image_bgr[y0:y1, x0:x1]
    if face.size == 0:
        return None, "face_crop_failed"

    sig = _face_signature_lbp(face)
    return sig, f"ok:face:haar:{face_box}"


def compare_biometric(captured_bgr: np.ndarray, template_bgr: np.ndarray, use_face_crop: bool = True, nfeatures: int = 800) -> float:
    """
    Robust biometric score in [0,1]:
      - primary: eye HS-hist correlation
      - fallback/augment: face LBP-hist correlation

    If both available -> weighted blend (eye dominates), else use what exists.
    If none available -> 0.0
    """
    if captured_bgr is None or template_bgr is None:
        return 0.0

    eye_a, ra = _extract_eye_signature(captured_bgr)
    eye_b, rb = _extract_eye_signature(template_bgr)

    face_a, rfa = _extract_face_signature(captured_bgr)
    face_b, rfb = _extract_face_signature(template_bgr)

    have_eye = (eye_a is not None and eye_b is not None)
    have_face = (face_a is not None and face_b is not None)

    if not have_eye and not have_face:
        return 0.0

    scores = []
    weights = []

    if have_eye:
        scores.append(_corr_similarity(eye_a, eye_b))
        weights.append(0.65)

    if have_face:
        scores.append(_corr_similarity(face_a, face_b))
        weights.append(0.35 if have_eye else 1.0)

    wsum = float(sum(weights))
    if wsum <= 0:
        return 0.0
    score = float(sum(s * w for s, w in zip(scores, weights)) / wsum)

    # clamp
    if score < 0.0:
        score = 0.0
    if score > 1.0:
        score = 1.0
    return score


def compare_biometric_debug(captured_bgr: np.ndarray, template_bgr: np.ndarray) -> Tuple[float, Dict[str, Any]]:
    """
    Returns (score, debug_dict) to diagnose demo_run mismatches.
    """
    dbg: Dict[str, Any] = {}

    eye_a, ra = _extract_eye_signature(captured_bgr) if captured_bgr is not None else (None, "captured_empty")
    eye_b, rb = _extract_eye_signature(template_bgr) if template_bgr is not None else (None, "template_empty")
    face_a, rfa = _extract_face_signature(captured_bgr) if captured_bgr is not None else (None, "captured_empty")
    face_b, rfb = _extract_face_signature(template_bgr) if template_bgr is not None else (None, "template_empty")

    dbg["captured_eye"] = ra
    dbg["template_eye"] = rb
    dbg["captured_face"] = rfa
    dbg["template_face"] = rfb

    have_eye = (eye_a is not None and eye_b is not None)
    have_face = (face_a is not None and face_b is not None)

    dbg["have_eye"] = have_eye
    dbg["have_face"] = have_face

    eye_score = None
    face_score = None

    if have_eye:
        eye_score = _corr_similarity(eye_a, eye_b)
    if have_face:
        face_score = _corr_similarity(face_a, face_b)

    dbg["eye_score"] = eye_score
    dbg["face_score"] = face_score

    score = compare_biometric(captured_bgr, template_bgr)
    dbg["final_score"] = score
    return score, dbg


FILE: src/camera.py
================================================================================
from __future__ import annotations

from dataclasses import dataclass

import cv2
import numpy as np


@dataclass
class CameraParams:
    index: int = 0
    warmup_frames: int = 10
    width: int = 640
    height: int = 480


def capture_frame(params: CameraParams) -> np.ndarray:
    cap = cv2.VideoCapture(params.index)
    if not cap.isOpened():
        raise RuntimeError(
            f"Cannot open camera index={params.index}. "
            f"Check VirtualBox settings (Devices -> Webcams) and permissions."
        )

    cap.set(cv2.CAP_PROP_FRAME_WIDTH, params.width)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, params.height)

    for _ in range(max(1, params.warmup_frames)):
        cap.read()

    ok, frame = cap.read()
    cap.release()

    if not ok or frame is None:
        raise RuntimeError("Camera capture failed (no frame returned).")

    return frame


FILE: src/card.py
================================================================================
from __future__ import annotations

import os
import time
import hashlib
from dataclasses import dataclass
from typing import Optional, Tuple, List

from smartcard.CardType import ATRCardType
from smartcard.CardRequest import CardRequest
from smartcard.CardConnection import CardConnection
from smartcard.Exceptions import CardConnectionException


class CardError(RuntimeError):
    pass


GCM_ATR = [0x3B, 0x02, 0x53, 0x01]
GCM_ATR_MASK = [0xFF, 0xFF, 0xFF, 0x00]
GCM_CARD_TYPE = ATRCardType(GCM_ATR, GCM_ATR_MASK)

INS_READ = 0xBE # read 4 bytes from an addr
INS_UPDATE = 0xDE # write 4 bytes to an addr
INS_VERIFY = 0x20 # verify code on card

ADDR_ISSUER_BASE = 0x01
ADDR_USER1_BASE = 0x10

APP_WORD_BASE = ADDR_USER1_BASE
APP_WORD_LEN = 10

MAGIC = b"CP01"

VERIFY_TARGET_CSC0 = 0x07
VERIFY_TARGET_CSC1 = 0x39
VERIFY_TARGET_CSC2 = 0x3B


def _sha256(b: bytes) -> bytes:
    return hashlib.sha256(b).digest()


def _chunks4(b: bytes):
    if len(b) % 4 != 0:
        raise CardError("record_length_not_multiple_of_4")
    return [b[i : i + 4] for i in range(0, len(b), 4)]


def _env_code4(name: str) -> Optional[bytes]:
    v = os.getenv(name, "").strip()
    if not v:
        return None
    v = v.lower().replace("0x", "").replace(" ", "")
    try:
        b = bytes.fromhex(v)
    except ValueError:
        raise CardError(f"bad_env_hex:{name}")
    if len(b) != 4:
        raise CardError(f"bad_env_len:{name}")
    return b


def _candidate_codes() -> List[bytes]:
    out: List[bytes] = []
    for k in ["CARTEPUCE_CSC1_HEX", "CARTEPUCE_CSC0_HEX", "CARTEPUCE_CSC2_HEX"]:
        b = _env_code4(k)
        if b:
            out.append(b)
    common = [
        b"\x11\x11\x11\x11",
        b"\x22\x22\x22\x22",
        b"\xAA\xAA\xAA\xAA",
        b"\x00\x00\x00\x00",
        b"\xFF\xFF\xFF\xFF",
    ]
    for c in common:
        if c not in out:
            out.append(c)
    return out


@dataclass
class AppRecord:
    card_uid: str
    user_hash8: str
    tpl_hash8: str


class CardSession:
    def __init__(self, timeout_seconds: int = 10):
        self.timeout_seconds = timeout_seconds
        self.cla = 0x80
        self._svc = None
        self._conn = None
        self.atr_hex = ""
        self._acquire()

    @property
    def conn(self):
        if self._conn is None:
            raise CardError("no_connection")
        return self._conn

    def _acquire(self) -> None:
        req = CardRequest(timeout=self.timeout_seconds, cardType=GCM_CARD_TYPE)
        svc = req.waitforcard()
        conn = svc.connection
        conn.connect(protocol=CardConnection.T0_protocol)
        atr = bytes(conn.getATR())
        self._svc = svc
        self._conn = conn
        self.atr_hex = " ".join(f"{x:02X}" for x in atr)

    def _reacquire(self) -> None:
        last = None
        for _ in range(3):
            try:
                self._acquire()
                return
            except Exception as e:
                last = e
                time.sleep(0.2)
        raise CardError(f"reacquire_failed:{last}")

    def _transmit(self, apdu) -> Tuple[bytes, int, int]:
        try:
            data, sw1, sw2 = self.conn.transmit(apdu)
            return bytes(data), sw1, sw2
        except CardConnectionException:
            self._reacquire()
            data, sw1, sw2 = self.conn.transmit(apdu)
            return bytes(data), sw1, sw2

    def read_word(self, addr: int) -> bytes:
        apdu = [self.cla, INS_READ, 0x00, addr & 0xFF, 0x04]
        data, sw1, sw2 = self._transmit(apdu)
        if (sw1, sw2) != (0x90, 0x00):
            raise CardError(f"read_word_sw={sw1:02X}{sw2:02X}")
        if len(data) != 4:
            raise CardError("read_word_len")
        return data

    def update_word(self, addr: int, word4: bytes) -> None:
        if len(word4) != 4:
            raise CardError("update_word_len")
        apdu = [self.cla, INS_UPDATE, 0x00, addr & 0xFF, 0x04] + list(word4)
        _, sw1, sw2 = self._transmit(apdu)
        if (sw1, sw2) != (0x90, 0x00):
            raise CardError(f"update_word_sw={sw1:02X}{sw2:02X}")

    def verify(self, target: int, code4: bytes) -> None:
        if len(code4) != 4:
            raise CardError("verify_len")
        apdu = [0x00, INS_VERIFY, 0x00, target & 0xFF, 0x04] + list(code4)
        _, sw1, sw2 = self._transmit(apdu)
        if (sw1, sw2) != (0x90, 0x00):
            raise CardError(f"verify_sw={sw1:02X}{sw2:02X}")

    def get_issuer_sn(self) -> bytes:
        out = b""
        for a in range(ADDR_ISSUER_BASE, ADDR_ISSUER_BASE + 4):
            out += self.read_word(a)
        return out

    def uid_from_issuer(self) -> str:
        issuer = self.get_issuer_sn()
        raw = issuer + bytes.fromhex(self.atr_hex.replace(" ", ""))
        return _sha256(raw)[:16].hex()

    def read_app_record(self) -> Optional[AppRecord]:
        raw = b""
        try:
            for i in range(APP_WORD_LEN):
                raw += self.read_word(APP_WORD_BASE + i)
        except Exception:
            return None

        if raw[:4] != MAGIC:
            return None

        card_uid = raw[4:20].hex()
        user_hash8 = raw[20:28].hex()
        tpl_hash8 = raw[28:36].hex()
        return AppRecord(card_uid=card_uid, user_hash8=user_hash8, tpl_hash8=tpl_hash8)

    def _build_record(self, card_uid16: bytes, user_id: str, tpl_sha256_hex: str) -> bytes:
        user_hash8 = _sha256(user_id.encode("utf-8"))[:8]
        tpl_hash8 = bytes.fromhex(tpl_sha256_hex)[:8]
        tail = b"\x00\x00\x00\x00"
        return MAGIC + card_uid16 + user_hash8 + tpl_hash8 + tail

    def _try_unlock_user1(self) -> None:
        codes = _candidate_codes()
        targets = [VERIFY_TARGET_CSC1, VERIFY_TARGET_CSC0, VERIFY_TARGET_CSC2]
        last_err = None
        for t in targets:
            for c in codes:
                try:
                    self.verify(t, c)
                    return
                except Exception as e:
                    last_err = e
                    continue
        raise CardError(f"unlock_failed:{last_err}")

    def write_app_record(self, user_id: str, tpl_sha256_hex: str, card_uid16: Optional[bytes] = None) -> str:
        if card_uid16 is None:
            card_uid16 = os.urandom(16)

        rec = self._build_record(card_uid16, user_id, tpl_sha256_hex)
        words = _chunks4(rec)

        self._try_unlock_user1()
        for i, w in enumerate(words):
            self.update_word(APP_WORD_BASE + i, w)

        return card_uid16.hex()

    def provision_or_load_uid(self, user_id: str, tpl_sha256_hex: str) -> Tuple[str, bool]:
        r = self.read_app_record()
        expected_user_hash8 = _sha256(user_id.encode("utf-8"))[:8].hex()
        expected_tpl_hash8 = bytes.fromhex(tpl_sha256_hex)[:8].hex()

        if r is None:
            uid = self.write_app_record(user_id=user_id, tpl_sha256_hex=tpl_sha256_hex, card_uid16=None)
            return uid, True

        if (r.user_hash8.lower() == expected_user_hash8.lower()) and (r.tpl_hash8.lower() == expected_tpl_hash8.lower()):
            return r.card_uid, False

        uid16 = bytes.fromhex(r.card_uid)
        uid = self.write_app_record(user_id=user_id, tpl_sha256_hex=tpl_sha256_hex, card_uid16=uid16)
        return uid, True

    def get_uid(self) -> Optional[str]:
        r = self.read_app_record()
        return None if r is None else r.card_uid


@dataclass
class CardInfo:
    card_id: Optional[str]
    atr_hex: Optional[str]


def get_card_id(simulate_card=None, timeout_seconds: int = 10) -> CardInfo:
    """Return CardInfo for the first detected card or simulated info.
    If a card is not present or an error occurs, returns CardInfo(card_id=None, atr_hex=None).
    """
    if simulate_card is not None:
        # expected format: {'card_id': str, 'atr_hex': str}
        return CardInfo(card_id=simulate_card.get('card_id'), atr_hex=simulate_card.get('atr_hex'))
    try:
        s = CardSession(timeout_seconds=timeout_seconds)
    except Exception:
        return CardInfo(card_id=None, atr_hex=None)
    return CardInfo(card_id=s.get_uid(), atr_hex=s.atr_hex)


def open_card(timeout_seconds: int = 10) -> CardSession:
    return CardSession(timeout_seconds=timeout_seconds)


FILE: src/config.py
================================================================================
from __future__ import annotations
import yaml
from dataclasses import dataclass
from typing import Any, Dict


@dataclass
class CameraConfig:
    index: int = 0
    warmup_frames: int = 10
    width: int = 640
    height: int = 480


@dataclass
class BiometricConfig:
    score_threshold: float = 0.18
    use_face_crop: bool = True
    orb_nfeatures: int = 800


@dataclass
class AuthConfig:
    required_factors: int = 3
    max_pin_attempts: int = 5
    lockout_seconds: int = 300
    enforce_card_binding: bool = True
    enforce_template_integrity: bool = True


@dataclass
class AppConfig:
    db_path: str = "data/app.db"
    camera: CameraConfig = CameraConfig()
    biometric: BiometricConfig = BiometricConfig()
    auth: AuthConfig = AuthConfig()


def load_config(path: str = "config.yaml") -> AppConfig:
    with open(path, "r", encoding="utf-8") as f:
        raw: Dict[str, Any] = yaml.safe_load(f) or {}

    cam = raw.get("camera", {}) or {}
    bio = raw.get("biometric", {}) or {}
    auth = raw.get("auth", {}) or {}

    return AppConfig(
        db_path=str(raw.get("db_path", "data/app.db")),
        camera=CameraConfig(
            index=int(cam.get("index", 0)),
            warmup_frames=int(cam.get("warmup_frames", 10)),
            width=int(cam.get("width", 640)),
            height=int(cam.get("height", 480)),
        ),
        biometric=BiometricConfig(
            score_threshold=float(bio.get("score_threshold", 0.18)),
            use_face_crop=bool(bio.get("use_face_crop", True)),
            orb_nfeatures=int(bio.get("orb_nfeatures", 800)),
        ),
        auth=AuthConfig(
            required_factors=int(auth.get("required_factors", 3)),
            max_pin_attempts=int(auth.get("max_pin_attempts", 5)),
            lockout_seconds=int(auth.get("lockout_seconds", 300)),
            enforce_card_binding=bool(auth.get("enforce_card_binding", True)),
            enforce_template_integrity=bool(auth.get("enforce_template_integrity", True)),
        ),
    )


FILE: src/db.py
================================================================================
from __future__ import annotations

import os
import sqlite3
import time
from typing import Optional, Any, Dict, Tuple


SCHEMA_SQL = """
PRAGMA journal_mode=WAL;

CREATE TABLE IF NOT EXISTS users (
  user_id      TEXT PRIMARY KEY,
  card_id      TEXT UNIQUE NOT NULL,
  card_atr     TEXT,
  pwd_salt     BLOB NOT NULL,
  pwd_hash     BLOB NOT NULL,
  created_at   TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE IF NOT EXISTS biometrics (
  user_id         TEXT PRIMARY KEY,
  template_path   TEXT NOT NULL,
  template_sha256 TEXT NOT NULL,
  algo            TEXT NOT NULL,
  created_at      TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY(user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS auth_state (
  user_id            TEXT PRIMARY KEY,
  fail_count         INTEGER NOT NULL DEFAULT 0,
  locked_until_epoch INTEGER,
  last_fail_epoch    INTEGER,
  updated_at         TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY(user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS auth_logs (
  id        INTEGER PRIMARY KEY AUTOINCREMENT,
  ts        TEXT NOT NULL DEFAULT (datetime('now')),
  card_id   TEXT,
  card_atr  TEXT,
  user_id   TEXT,
  pwd_ok    INTEGER,
  bio_score REAL,
  decision  TEXT,
  reason    TEXT
);
"""


def ensure_parent_dir(db_path: str) -> None:
    parent = os.path.dirname(db_path)
    if parent:
        os.makedirs(parent, exist_ok=True)


def connect(db_path: str) -> sqlite3.Connection:
    ensure_parent_dir(db_path)
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row
    conn.execute("PRAGMA foreign_keys=ON;")
    return conn


def _ensure_column(conn: sqlite3.Connection, table: str, col: str, ddl: str) -> None:
    cols = [r["name"] for r in conn.execute(f"PRAGMA table_info({table})").fetchall()]
    if col not in cols:
        conn.execute(f"ALTER TABLE {table} ADD COLUMN {ddl}")
        conn.commit()


def init_db(conn: sqlite3.Connection) -> None:
    conn.executescript(SCHEMA_SQL)
    conn.commit()
    _ensure_column(conn, "users", "card_atr", "card_atr TEXT")
    _ensure_column(conn, "auth_logs", "card_atr", "card_atr TEXT")


def upsert_user(
    conn: sqlite3.Connection,
    user_id: str,
    card_id: str,
    pwd_salt: bytes,
    pwd_hash: bytes,
    card_atr: Optional[str] = None,
) -> None:
    conn.execute(
        """
        INSERT INTO users(user_id, card_id, card_atr, pwd_salt, pwd_hash)
        VALUES(?, ?, ?, ?, ?)
        ON CONFLICT(user_id) DO UPDATE SET
          card_id=excluded.card_id,
          card_atr=excluded.card_atr,
          pwd_salt=excluded.pwd_salt,
          pwd_hash=excluded.pwd_hash
        """,
        (user_id, card_id, card_atr, pwd_salt, pwd_hash),
    )
    conn.commit()


def update_user_pin(conn: sqlite3.Connection, user_id: str, pwd_salt: bytes, pwd_hash: bytes) -> None:
    conn.execute(
        """
        UPDATE users SET pwd_salt=?, pwd_hash=? WHERE user_id=?
        """,
        (pwd_salt, pwd_hash, user_id),
    )
    conn.commit()


def upsert_biometric(
    conn: sqlite3.Connection,
    user_id: str,
    template_path: str,
    template_sha256: str,
    algo: str,
) -> None:
    conn.execute(
        """
        INSERT INTO biometrics(user_id, template_path, template_sha256, algo)
        VALUES(?, ?, ?, ?)
        ON CONFLICT(user_id) DO UPDATE SET
          template_path=excluded.template_path,
          template_sha256=excluded.template_sha256,
          algo=excluded.algo
        """,
        (user_id, template_path, template_sha256, algo),
    )
    conn.commit()


def get_user_by_card(conn: sqlite3.Connection, card_id: str) -> Optional[Dict[str, Any]]:
    row = conn.execute(
        """
        SELECT u.user_id, u.card_id, u.card_atr, u.pwd_salt, u.pwd_hash,
               b.template_path, b.template_sha256, b.algo
        FROM users u
        LEFT JOIN biometrics b ON b.user_id = u.user_id
        WHERE u.card_id = ?
        """,
        (card_id,),
    ).fetchone()
    return dict(row) if row else None


def get_user_by_id(conn: sqlite3.Connection, user_id: str) -> Optional[Dict[str, Any]]:
    row = conn.execute(
        """
        SELECT u.user_id, u.card_id, u.card_atr, u.pwd_salt, u.pwd_hash,
               b.template_path, b.template_sha256, b.algo
        FROM users u
        LEFT JOIN biometrics b ON b.user_id = u.user_id
        WHERE u.user_id = ?
        """,
        (user_id,),
    ).fetchone()
    return dict(row) if row else None


def _ensure_auth_state(conn: sqlite3.Connection, user_id: str) -> None:
    conn.execute(
        """
        INSERT INTO auth_state(user_id, fail_count, locked_until_epoch, last_fail_epoch)
        VALUES(?, 0, NULL, NULL)
        ON CONFLICT(user_id) DO NOTHING
        """,
        (user_id,),
    )
    conn.commit()


def get_auth_state(conn: sqlite3.Connection, user_id: str) -> Dict[str, Any]:
    _ensure_auth_state(conn, user_id)
    row = conn.execute(
        """
        SELECT user_id, fail_count, locked_until_epoch, last_fail_epoch
        FROM auth_state WHERE user_id=?
        """,
        (user_id,),
    ).fetchone()
    return dict(row) if row else {"user_id": user_id, "fail_count": 0, "locked_until_epoch": None, "last_fail_epoch": None}


def is_locked(conn: sqlite3.Connection, user_id: str, now_epoch: Optional[int] = None) -> Tuple[bool, Optional[int]]:
    st = get_auth_state(conn, user_id)
    locked_until = st.get("locked_until_epoch")
    if locked_until is None:
        return False, None
    if now_epoch is None:
        now_epoch = int(time.time())
    return now_epoch < int(locked_until), int(locked_until)


def record_pin_failure(
    conn: sqlite3.Connection,
    user_id: str,
    now_epoch: int,
    max_attempts: int,
    lockout_seconds: int,
) -> Dict[str, Any]:
    st = get_auth_state(conn, user_id)
    fail_count = int(st.get("fail_count") or 0) + 1
    locked_until = st.get("locked_until_epoch")
    if max_attempts > 0 and fail_count >= max_attempts:
        locked_until = int(now_epoch + max(1, lockout_seconds))
    conn.execute(
        """
        UPDATE auth_state
        SET fail_count=?, locked_until_epoch=?, last_fail_epoch=?, updated_at=datetime('now')
        WHERE user_id=?
        """,
        (fail_count, locked_until, int(now_epoch), user_id),
    )
    conn.commit()
    return {"user_id": user_id, "fail_count": fail_count, "locked_until_epoch": locked_until}


def clear_auth_state(conn: sqlite3.Connection, user_id: str) -> None:
    _ensure_auth_state(conn, user_id)
    conn.execute(
        """
        UPDATE auth_state
        SET fail_count=0, locked_until_epoch=NULL, last_fail_epoch=NULL, updated_at=datetime('now')
        WHERE user_id=?
        """,
        (user_id,),
    )
    conn.commit()


def log_auth(
    conn: sqlite3.Connection,
    card_id: str,
    card_atr: Optional[str],
    user_id: Optional[str],
    pwd_ok: bool,
    bio_score: Optional[float],
    decision: str,
    reason: str,
) -> None:
    conn.execute(
        """
        INSERT INTO auth_logs(card_id, card_atr, user_id, pwd_ok, bio_score, decision, reason)
        VALUES(?, ?, ?, ?, ?, ?, ?)
        """,
        (card_id, card_atr, user_id, int(pwd_ok), bio_score, decision, reason),
    )
    conn.commit()


FILE: src/security/__init__.py
================================================================================
# src/security/__init__.py
"""
Security package.

This package centralizes:
- Password hashing / verification (PBKDF2 + optional pepper)
- HMAC-based challenge-response primitives (nonce/counter/context/tag)
- Replay protection (nonce cache, in-memory demo-grade)
- Template integrity checks (anti-tamper)
- Audit context encoding (compact, log-friendly)

Backward compatibility:
Existing imports like:
    from src.security import pbkdf2_hash_pin, verify_pin
should continue to work.
"""

from .password_hashing import pbkdf2_hash_pin, verify_pin
from .hmac_challenge_response import (
    generate_nonce,
    compute_hmac_tag,
    verify_hmac_tag,
    new_card_key,
    key_id_from_key,
    build_hmac_message,
)
from .replay_protection import NonceReplayProtector
from .template_integrity import sha256_file_hex, verify_file_sha256
from .audit_logging import (
    build_audit_context,
    encode_audit_context,
    compact_reason,
)


FILE: src/security/audit_logging.py
================================================================================
# src/security/audit_logging.py
from __future__ import annotations

import json
import os
import platform
from typing import Any, Dict, Optional


def _device_identity() -> str:
    """
    Best-effort device identifier for audit logs.
    Not a security guarantee; used to support threat analysis (stolen reader / tampered terminal).
    """
    host = platform.node() or "unknown-host"
    sysname = platform.system() or "unknown-os"
    return f"{sysname}:{host}"


def build_audit_context(
    *,
    nonce: Optional[bytes] = None,
    counter: Optional[int] = None,
    key_id: Optional[str] = None,
    tag: Optional[bytes] = None,
    context: Optional[str] = None,
    extra: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    """
    Build a JSON-serializable dict for audit logs.
    """
    d: Dict[str, Any] = {
        "device": _device_identity(),
    }

    if nonce is not None:
        d["nonce"] = bytes(nonce).hex()
    if counter is not None:
        d["counter"] = int(counter)
    if key_id is not None:
        d["key_id"] = str(key_id)
    if tag is not None:
        d["tag"] = bytes(tag).hex()
    if context is not None:
        d["context"] = str(context)

    if extra:
        # Ensure extra is JSON-serializable
        for k, v in extra.items():
            d[str(k)] = v

    return d


def encode_audit_context(ctx: Dict[str, Any], max_len: int = 512) -> str:
    """
    Encode context as compact JSON string.
    If too long, truncate deterministically.
    """
    s = json.dumps(ctx, separators=(",", ":"), ensure_ascii=False)
    if len(s) <= max_len:
        return s
    return s[: max_len - 3] + "..."


def compact_reason(reason: str, audit_context_json: Optional[str] = None) -> str:
    """
    Pack reason + audit context into a single string suitable for existing auth_logs.reason.

    Example:
      "bad_pin|ctx={...}"
    """
    r = (reason or "").strip() or "unknown"
    if not audit_context_json:
        return r
    return f"{r}|ctx={audit_context_json}"


FILE: src/security/hmac_challenge_response.py
================================================================================
# src/security/hmac_challenge_response.py
from __future__ import annotations

import hashlib
import hmac
import os
from typing import Tuple


_HMAC_VERSION_PREFIX = b"CP-AUTH-HMAC-V1\x00"


def generate_nonce(length: int = 16) -> bytes:
    """
    Random nonce for each authentication attempt.
    16 bytes is sufficient for demo-grade replay protection.
    """
    if length < 12:
        raise ValueError("nonce_length_too_small")
    return os.urandom(length)


def new_card_key(length: int = 32) -> bytes:
    """
    Generate per-card secret key K_card.
    """
    if length < 16:
        raise ValueError("card_key_length_too_small")
    return os.urandom(length)


def key_id_from_key(k_card: bytes, length: int = 8) -> str:
    """
    Derive a public key identifier (not secret) from K_card.
    Can be stored on card as key_id to locate DB record.

    Default: 8 bytes (16 hex chars).
    """
    if length < 4:
        raise ValueError("key_id_length_too_small")
    digest = hashlib.sha256(k_card).digest()
    return digest[:length].hex()


def _card_uid_hex_to_bytes(card_uid_hex: str) -> bytes:
    s = (card_uid_hex or "").strip().lower()
    if len(s) != 32:
        # Your current card_uid is 16 bytes hex => 32 chars
        raise ValueError("card_uid_expected_16_bytes_hex")
    return bytes.fromhex(s)


def build_hmac_message(
    card_uid_hex: str,
    nonce: bytes,
    counter: int,
    context: str,
) -> bytes:
    """
    Canonical message: prefix || card_uid(16B) || nonce || counter(4B BE) || context(utf-8)
    """
    if not isinstance(nonce, (bytes, bytearray)) or len(nonce) < 12:
        raise ValueError("invalid_nonce")
    if counter < 0 or counter > 0xFFFFFFFF:
        raise ValueError("counter_out_of_range")

    card_uid = _card_uid_hex_to_bytes(card_uid_hex)
    counter_be = int(counter).to_bytes(4, "big", signed=False)
    ctx = (context or "").encode("utf-8")

    return _HMAC_VERSION_PREFIX + card_uid + bytes(nonce) + counter_be + ctx


def compute_hmac_tag(k_card: bytes, message: bytes, tag_len: int = 32) -> bytes:
    """
    Compute HMAC-SHA256 tag (optionally truncated).
    """
    if not isinstance(k_card, (bytes, bytearray)) or len(k_card) < 16:
        raise ValueError("invalid_k_card")
    full = hmac.new(bytes(k_card), message, hashlib.sha256).digest()
    if tag_len <= 0 or tag_len > len(full):
        raise ValueError("invalid_tag_len")
    return full[:tag_len]


def verify_hmac_tag(k_card: bytes, message: bytes, tag: bytes) -> bool:
    """
    Constant-time verification.
    """
    if not isinstance(tag, (bytes, bytearray)) or len(tag) == 0:
        return False
    expected = compute_hmac_tag(k_card, message, tag_len=len(tag))
    return hmac.compare_digest(expected, bytes(tag))


FILE: src/security/password_hashing.py
================================================================================
# src/security/password_hashing.py
from __future__ import annotations

import base64
import hashlib
import hmac
import os
from typing import Optional, Tuple


_DEFAULT_ITERATIONS = 200_000


def _load_pepper_bytes() -> bytes:
    """
    Optional server-side secret (pepper) to harden against offline guessing after DB compromise.
    - If unset: return b"" (no pepper).
    - If set: supports either raw string or base64 prefixed with "base64:".

    Environment variable:
      CARTEPUCE_PASSWORD_PEPPER
        examples:
          export CARTEPUCE_PASSWORD_PEPPER="my-long-random-pepper"
          export CARTEPUCE_PASSWORD_PEPPER="base64:8cS7...=="
    """
    v = (os.environ.get("CARTEPUCE_PASSWORD_PEPPER") or "").strip()
    if not v:
        return b""
    if v.startswith("base64:"):
        return base64.b64decode(v[len("base64:") :].encode("utf-8"))
    return v.encode("utf-8")


def pbkdf2_hash_pin(
    pin: str,
    salt: Optional[bytes] = None,
    iterations: int = _DEFAULT_ITERATIONS,
) -> Tuple[bytes, bytes]:
    """
    Return (salt, derived_key).

    NOTE:
    - The pepper is NOT stored in DB.
    - If you set pepper later, you should re-enroll users for strict correctness,
      but verify_pin() is backward-compatible by trying both modes.
    """
    if salt is None:
        salt = os.urandom(16)

    pepper = _load_pepper_bytes()
    material = pin.encode("utf-8") + pepper

    dk = hashlib.pbkdf2_hmac("sha256", material, salt, iterations, dklen=32)
    return salt, dk


def verify_pin(
    pin: str,
    salt: bytes,
    expected_hash: bytes,
    iterations: int = _DEFAULT_ITERATIONS,
) -> bool:
    """
    Constant-time verification.

    Backward compatibility strategy:
    - If pepper is configured, try with pepper first.
    - If fails and pepper is configured, try without pepper (older DB entries).
    """
    pepper = _load_pepper_bytes()

# Try with current pepper mode
    material = pin.encode("utf-8") + pepper
    dk = hashlib.pbkdf2_hmac("sha256", material, salt, iterations, dklen=32)
    if hmac.compare_digest(dk, expected_hash):
        return True

    # Fallback: no-pepper compatibility
    if pepper:
        dk2 = hashlib.pbkdf2_hmac("sha256", pin.encode("utf-8"), salt, iterations, dklen=32)
        return hmac.compare_digest(dk2, expected_hash)

    return False


FILE: src/security/replay_protection.py
================================================================================
# src/security/replay_protection.py
from __future__ import annotations

import time
from dataclasses import dataclass
from typing import Dict, Tuple


@dataclass
class ReplayDecision:
    ok: bool
    reason: str


class NonceReplayProtector:
    """
    In-memory nonce replay protector.
    Scope: current process only.

    Strategy:
      - (card_id, nonce_hex) -> expiry_ts
      - If seen and not expired => replay

    Parameters:
      ttl_seconds: how long a nonce is considered valid for anti-replay purposes.
      max_entries: crude memory bound; oldest entries are evicted when over limit.
    """

    def __init__(self, ttl_seconds: int = 120, max_entries: int = 4096):
        if ttl_seconds <= 0:
            raise ValueError("ttl_seconds_must_be_positive")
        if max_entries < 64:
            raise ValueError("max_entries_too_small")
        self.ttl_seconds = ttl_seconds
        self.max_entries = max_entries
        self._store: Dict[Tuple[str, str], float] = {}

    def _purge_expired(self, now: float) -> None:
        expired = [k for k, exp in self._store.items() if exp <= now]
        for k in expired:
            self._store.pop(k, None)

    def _evict_if_needed(self) -> None:
        if len(self._store) <= self.max_entries:
            return
        # Evict earliest-expiring items first
        items = sorted(self._store.items(), key=lambda kv: kv[1])
        for (k, _exp) in items[: max(1, len(self._store) - self.max_entries)]:
            self._store.pop(k, None)

    def check_and_remember(self, card_id: str, nonce: bytes) -> ReplayDecision:
        now = time.time()
        self._purge_expired(now)

        nonce_hex = bytes(nonce).hex()
        key = (card_id, nonce_hex)

        if key in self._store:
            return ReplayDecision(ok=False, reason="replay_nonce_seen")

        self._store[key] = now + self.ttl_seconds
        self._evict_if_needed()
        return ReplayDecision(ok=True, reason="ok")


FILE: src/security/template_integrity.py
================================================================================
# src/security/template_integrity.py
from __future__ import annotations

import hashlib
import os


def sha256_file_hex(path: str) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()


def verify_file_sha256(path: str, expected_hex: str) -> bool:
    """
    Returns True if the file exists and matches expected sha256 hex.
    """
    if not path or not os.path.exists(path) or not os.path.isfile(path):
        return False
    expected = (expected_hex or "").strip().lower()
    if len(expected) != 64:
        return False
    actual = sha256_file_hex(path)
    return actual == expected


FILE: src/vision_backend.py
================================================================================
# FILE: src/vision_backend.py
from __future__ import annotations

import os
import re
import subprocess
from dataclasses import dataclass
from typing import Optional, Tuple, List


@dataclass
class FaceEyesDet:
    face_ok: bool
    eyes_ok: bool
    face_center: Optional[Tuple[int, int]] = None
    eye1: Optional[Tuple[int, int]] = None
    eye2: Optional[Tuple[int, int]] = None
    eye_r: Optional[int] = None
    raw: str = ""


_FACE_RE = re.compile(r"Face\s*=\s*\(\s*(\-?\d+)\s*,\s*(\-?\d+)\s*\)")
_EYES_RE = re.compile(
    r"Eyes\s*=\s*\(\s*(\-?\d+)\s*,\s*(\-?\d+)\s*\)\s+"
    r"\(\s*(\-?\d+)\s*,\s*(\-?\d+)\s*\).*?\br\s*=\s*(\d+)"
)


def _default_bin_path() -> str:
    # CartePuce/vision/bin/ght_face_eyes
    here = os.path.dirname(os.path.abspath(__file__))
    root = os.path.abspath(os.path.join(here, ".."))
    return os.path.join(root, "vision", "bin", "ght_face_eyes")


def detect_face_eyes_by_ght(
    image_path: str,
    bin_path: Optional[str] = None,
    timeout_sec: int = 5,
    headless: bool = True,
    gui: bool = False,
    gui_steps: bool = False,
    gui_delay_ms: int = 0,
    # New knobs (optional)
    auto_threshold: bool = True,
    face_edge: Optional[int] = None,
    eye_edge: Optional[int] = None,
    face_min_score: Optional[int] = None,
    eye_min_peak: Optional[int] = None,
    eq_hist: bool = True,
    clahe: bool = False,
    blur_k: int = 5,
) -> FaceEyesDet:
    """
    Call C++ GHT detector and parse stdout for Face/Eyes.

      ght_face_eyes --image <path> [--gui] [--no-gui] [--gui-steps] [--gui-delay-ms <N>]
                   [--no-auto-threshold] [--face-edge v] [--eye-edge v]
                   [--no-eq] [--clahe] [--blur k]
                   [--face-min-score v] [--eye-min-peak v]
    """
    if not image_path or not os.path.exists(image_path):
        return FaceEyesDet(face_ok=False, eyes_ok=False, raw="image_not_found")

    exe = bin_path or _default_bin_path()
    if not os.path.exists(exe):
        return FaceEyesDet(face_ok=False, eyes_ok=False, raw=f"vision_binary_not_found:{exe}")

    cmd: List[str] = [exe, "--image", image_path]

    # GUI/headless controls
    if gui or gui_steps or (gui_delay_ms and gui_delay_ms > 0):
        cmd.append("--gui")
        if gui_steps:
            cmd.append("--gui-steps")
        if gui_delay_ms and gui_delay_ms > 0:
            cmd.extend(["--gui-delay-ms", str(int(gui_delay_ms))])
    elif headless:
        cmd.append("--no-gui")

    # preprocessing flags
    if not auto_threshold:
        cmd.append("--no-auto-threshold")
    if not eq_hist:
        cmd.append("--no-eq")
    if clahe:
        cmd.append("--clahe")
    if blur_k is not None:
        cmd.extend(["--blur", str(int(blur_k))])

    # thresholds
    if face_edge is not None:
        cmd.extend(["--face-edge", str(int(face_edge))])
    if eye_edge is not None:
        cmd.extend(["--eye-edge", str(int(eye_edge))])
    if face_min_score is not None:
        cmd.extend(["--face-min-score", str(int(face_min_score))])
    if eye_min_peak is not None:
        cmd.extend(["--eye-min-peak", str(int(eye_min_peak))])

    try:
        cp = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout_sec,
            check=False,
        )
    except subprocess.TimeoutExpired:
        return FaceEyesDet(face_ok=False, eyes_ok=False, raw="vision_timeout")
    except Exception as e:
        return FaceEyesDet(face_ok=False, eyes_ok=False, raw=f"vision_exec_error:{e}")

    out = (cp.stdout or "").strip()
    err = (cp.stderr or "").strip()

    raw = (
        f"cmd={cmd}\n"
        f"returncode={cp.returncode}\n"
        f"--- stdout ---\n{out}\n"
        f"--- stderr ---\n{err}\n"
    ).strip()

    parse_text = out if out else err
    if not parse_text:
        return FaceEyesDet(face_ok=False, eyes_ok=False, raw="no_output_from_vision_binary\n" + raw)

    face_notfound = re.search(r"Face\s*=\s*NOTFOUND", parse_text) is not None
    eyes_notfound = re.search(r"Eyes\s*=\s*NOTFOUND", parse_text) is not None

    fm = _FACE_RE.search(parse_text)
    em = _EYES_RE.search(parse_text)

    face_ok = (not face_notfound) and (fm is not None)
    eyes_ok = (not eyes_notfound) and (em is not None)

    det = FaceEyesDet(face_ok=face_ok, eyes_ok=eyes_ok, raw=raw)

    if fm:
        det.face_center = (int(fm.group(1)), int(fm.group(2)))

    if em:
        det.eye1 = (int(em.group(1)), int(em.group(2)))
        det.eye2 = (int(em.group(3)), int(em.group(4)))
        det.eye_r = int(em.group(5))

    return det


FILE: vision/src/ght_face_eyes.cpp
================================================================================
// FILE: vision/src/ght_face_eyes.cpp
#include <opencv2/core.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>

#include <algorithm>
#include <array>
#include <cstdint>
#include <cstdlib>
#include <cmath>
#include <chrono>
#include <iostream>
#include <limits>
#include <string>
#include <vector>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// -------------------- utils --------------------
static int clampInt(int v, int minV, int maxV) {
    if (v < minV) return minV;
    if (v > maxV) return maxV;
    return v;
}

static int binDeg(float radians) {
    float deg = radians * 180.0f / float(M_PI);
    int b = (int)std::lround(deg);
    b %= 360;
    if (b < 0) b += 360;
    return b;
}

static void showStep(const std::string& name, const cv::Mat& m, bool steps, int delayMs) {
    cv::imshow(name, m);
    if (steps) cv::waitKey(0);
    else if (delayMs > 0) cv::waitKey(delayMs);
}

// -------------------- image struct --------------------
struct grayImage {
    int w = 0, h = 0;
    std::vector<uint8_t> p;

    uint8_t& at(int y, int x) { return p[(size_t)y * (size_t)w + (size_t)x]; }
    uint8_t  at(int y, int x) const { return p[(size_t)y * (size_t)w + (size_t)x]; }
};

static grayImage matToGrayImageU8(const cv::Mat& grayU8) {
    grayImage g;
    g.w = grayU8.cols;
    g.h = grayU8.rows;
    g.p.assign((size_t)g.w * (size_t)g.h, 0);
    for (int y = 0; y < g.h; ++y) {
        const uint8_t* row = grayU8.ptr<uint8_t>(y);
        for (int x = 0; x < g.w; ++x) g.at(y, x) = row[x];
    }
    return g;
}

static cv::Mat toMatGray8(const grayImage& g) {
    cv::Mat m(g.h, g.w, CV_8UC1);
    for (int y = 0; y < g.h; ++y) {
        uint8_t* row = m.ptr<uint8_t>(y);
        for (int x = 0; x < g.w; ++x) row[x] = g.at(y, x);
    }
    return m;
}

// -------------------- gradients --------------------
struct ChampGradient {
    int w = 0, h = 0;
    std::vector<uint16_t> mag;
    std::vector<uint16_t> ang;

    uint16_t& m(int y, int x) { return mag[(size_t)y * (size_t)w + (size_t)x]; }
    uint16_t  m(int y, int x) const { return mag[(size_t)y * (size_t)w + (size_t)x]; }
    uint16_t& a(int y, int x) { return ang[(size_t)y * (size_t)w + (size_t)x]; }
    uint16_t  a(int y, int x) const { return ang[(size_t)y * (size_t)w + (size_t)x]; }
};

static ChampGradient sobel(const grayImage& img) {
    ChampGradient cg;
    cg.w = img.w;
    cg.h = img.h;
    cg.mag.assign((size_t)cg.w * (size_t)cg.h, 0);
    cg.ang.assign((size_t)cg.w * (size_t)cg.h, 0);

    auto at = [&](int y, int x) -> int {
        x = clampInt(x, 0, img.w - 1);
        y = clampInt(y, 0, img.h - 1);
        return (int)img.at(y, x);
    };

    for (int y = 0; y < img.h; ++y) {
        for (int x = 0; x < img.w; ++x) {
            int gx =
                -1 * at(y - 1, x - 1) + 1 * at(y - 1, x + 1) +
                -2 * at(y,     x - 1) + 2 * at(y,     x + 1) +
                -1 * at(y + 1, x - 1) + 1 * at(y + 1, x + 1);

            int gy =
                -1 * at(y - 1, x - 1) + -2 * at(y - 1, x) + -1 * at(y - 1, x + 1) +
                 1 * at(y + 1, x - 1) +  2 * at(y + 1, x) +  1 * at(y + 1, x + 1);

            float mag = std::sqrt((float)gx * (float)gx + (float)gy * (float)gy);
            float ang = std::atan2((float)gy, (float)gx);

            cg.m(y, x) = (uint16_t)clampInt((int)std::lround(mag), 0, 65535);
            cg.a(y, x) = (uint16_t)binDeg(ang);
        }
    }
    return cg;
}

static cv::Mat toMatMag8_norm(const ChampGradient& cg) {
    cv::Mat m(cg.h, cg.w, CV_8UC1);
    uint16_t minv = std::numeric_limits<uint16_t>::max();
    uint16_t maxv = 0;

    for (int y = 0; y < cg.h; ++y) {
        for (int x = 0; x < cg.w; ++x) {
            uint16_t v = cg.m(y, x);
            minv = std::min(minv, v);
            maxv = std::max(maxv, v);
        }
    }
    if (maxv <= minv) { m.setTo(0); return m; }

    for (int y = 0; y < cg.h; ++y) {
        uint8_t* row = m.ptr<uint8_t>(y);
        for (int x = 0; x < cg.w; ++x) {
            float f = (float)(cg.m(y, x) - minv) / (float)(maxv - minv);
            row[x] = (uint8_t)clampInt((int)std::lround(255.0f * f), 0, 255);
        }
    }
    return m;
}

// -------------------- accumulator + R-Table --------------------
struct AccuImage {
    int w = 0, h = 0;
    std::vector<uint16_t> a;

    uint16_t& at(int y, int x) { return a[(size_t)y * (size_t)w + (size_t)x]; }
    uint16_t  at(int y, int x) const { return a[(size_t)y * (size_t)w + (size_t)x]; }
};

static AccuImage makeAccu(int w, int h) {
    AccuImage A;
    A.w = w; A.h = h;
    A.a.assign((size_t)w * (size_t)h, 0);
    return A;
}

static uint16_t accuPeak(const AccuImage& A, int* outX = nullptr, int* outY = nullptr) {
    uint16_t peak = 0;
    int px = 0, py = 0;
    for (int y = 0; y < A.h; ++y) {
        for (int x = 0; x < A.w; ++x) {
            uint16_t v = A.at(y, x);
            if (v >= peak) { peak = v; px = x; py = y; }
        }
    }
    if (outX) *outX = px;
    if (outY) *outY = py;
    return peak;
}

static cv::Mat toMatAccu8(const AccuImage& A) {
    cv::Mat m(A.h, A.w, CV_8UC1);
    uint16_t maxv = 1;
    for (int y = 0; y < A.h; ++y)
        for (int x = 0; x < A.w; ++x)
            maxv = std::max<uint16_t>(maxv, A.at(y, x));

    for (int y = 0; y < A.h; ++y) {
        uint8_t* row = m.ptr<uint8_t>(y);
        for (int x = 0; x < A.w; ++x) {
            float f = (float)A.at(y, x) / (float)maxv;
            row[x] = (uint8_t)clampInt((int)std::lround(255.0f * f), 0, 255);
        }
    }
    return m;
}

struct RTable {
    std::array<std::vector<std::pair<int16_t, int16_t>>, 360> lut;
};

static void voterWeighted(
    AccuImage& A,
    const ChampGradient& grads,
    const RTable& rtable,
    uint16_t seuilMag
) {
    // 按梯度幅值加权：让峰值真正“长起来”
    // weight = 1 + mag/80  (上限截断，防止离谱)
    for (int y = 0; y < grads.h; ++y) {
        for (int x = 0; x < grads.w; ++x) {
            uint16_t mag = grads.m(y, x);
            if (mag < seuilMag) continue;
            uint16_t ang = grads.a(y, x);
            const auto& vec = rtable.lut[(size_t)ang];
            if (vec.empty()) continue;

            int w = 1 + (int)(mag / 80);
            w = clampInt(w, 1, 12);

            for (const auto& d : vec) {
                int cx = x + d.first;
                int cy = y + d.second;
                if (cx < 0 || cy < 0 || cx >= A.w || cy >= A.h) continue;

                uint32_t v = (uint32_t)A.at(cy, cx) + (uint32_t)w;
                if (v > 65535) v = 65535;
                A.at(cy, cx) = (uint16_t)v;
            }
        }
    }
}

// -------------------- templates (thicker edges) --------------------
static grayImage makeGray(int w, int h, uint8_t v) {
    grayImage g;
    g.w = w; g.h = h;
    g.p.assign((size_t)w * (size_t)h, v);
    return g;
}

static grayImage templateEllipse(int w, int h, float rx, float ry) {
    // 黑底(0) + 白边(255)，边缘更厚一点，方便生成充足 RTable
    grayImage t = makeGray(w, h, 0);
    float cx = 0.5f * (float)(w - 1);
    float cy = 0.5f * (float)(h - 1);

    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            float dx = ((float)x - cx) / rx;
            float dy = ((float)y - cy) / ry;
            float v = dx * dx + dy * dy;
            if (std::abs(v - 1.0f) < 0.07f) { // 变厚
                t.at(y, x) = 255;
            }
        }
    }
    return t;
}

static grayImage templateCercle(int w, int h, float r) {
    grayImage t = makeGray(w, h, 0);
    float cx = 0.5f * (float)(w - 1);
    float cy = 0.5f * (float)(h - 1);

    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            float dx = (float)x - cx;
            float dy = (float)y - cy;
            float d = std::sqrt(dx * dx + dy * dy);
            if (std::abs(d - r) < 2.5f) { // 变厚
                t.at(y, x) = 255;
            }
        }
    }
    return t;
}

static RTable construireRTableDepuisTemplate(const grayImage& templ, uint16_t minMag) {
    // 关键修复：只做 minMag 下限过滤，不要 maxMag 上限过滤（容易把模板梯度点过滤没）
    ChampGradient g = sobel(templ);

    int cx = templ.w / 2;
    int cy = templ.h / 2;

    RTable rt;
    for (int y = 0; y < templ.h; ++y) {
        for (int x = 0; x < templ.w; ++x) {
            uint16_t mag = g.m(y, x);
            if (mag < minMag) continue;

            uint16_t ang = g.a(y, x);
            int dx = cx - x;
            int dy = cy - y;
            rt.lut[(size_t)ang].push_back({(int16_t)dx, (int16_t)dy});
        }
    }
    return rt;
}

// -------------------- models --------------------
struct facemodel { int rx = 0, ry = 0; RTable lut; };
struct eyemodel  { int r = 0; RTable lut; };

// -------------------- peaks list for eyes --------------------
struct PicPoint {
    int x = 0, y = 0;
    float bx = 0.0f, by = 0.0f;
    uint16_t v = 0;
};

static std::vector<PicPoint> topKpicsAvecBary(
    const AccuImage& A,
    int k,
    int nmsRadius,
    int baryRadius,
    uint16_t minVal
) {
    struct Cand { int x,y; uint16_t v; };
    std::vector<Cand> cands;
    cands.reserve(2048);

    for (int y = 0; y < A.h; ++y)
        for (int x = 0; x < A.w; ++x)
            if (A.at(y, x) >= minVal) cands.push_back({x,y,A.at(y,x)});

    std::sort(cands.begin(), cands.end(),
              [](const Cand& a, const Cand& b){ return a.v > b.v; });

    std::vector<PicPoint> out;
    for (const auto& c : cands) {
        bool tooClose = false;
        for (const auto& p : out) {
            int dx = c.x - p.x;
            int dy = c.y - p.y;
            if (dx*dx + dy*dy <= nmsRadius*nmsRadius) { tooClose = true; break; }
        }
        if (tooClose) continue;

        int x0 = clampInt(c.x - baryRadius, 0, A.w - 1);
        int x1 = clampInt(c.x + baryRadius, 0, A.w - 1);
        int y0 = clampInt(c.y - baryRadius, 0, A.h - 1);
        int y1 = clampInt(c.y + baryRadius, 0, A.h - 1);

        double sum = 0.0, sx = 0.0, sy = 0.0;
        for (int y = y0; y <= y1; ++y) {
            for (int x = x0; x <= x1; ++x) {
                double w = (double)A.at(y, x);
                sum += w;
                sx += w * (double)x;
                sy += w * (double)y;
            }
        }

        PicPoint pp;
        pp.x = c.x; pp.y = c.y; pp.v = c.v;
        if (sum > 0.0) { pp.bx = (float)(sx / sum); pp.by = (float)(sy / sum); }
        else { pp.bx = (float)c.x; pp.by = (float)c.y; }

        out.push_back(pp);
        if ((int)out.size() >= k) break;
    }
    return out;
}

static bool choisirPaireYeux(
    const std::vector<PicPoint>& pics,
    int faceCxInZone,
    int faceCyInZone,
    int minDx, int maxDx,
    int maxDy,
    PicPoint& left,
    PicPoint& right
) {
    bool found = false;
    uint32_t best = 0;
    for (size_t i = 0; i < pics.size(); ++i) {
        for (size_t j = i + 1; j < pics.size(); ++j) {
            const auto& p1 = pics[i];
            const auto& p2 = pics[j];
            const auto& L = (p1.bx <= p2.bx) ? p1 : p2;
            const auto& R = (p1.bx <= p2.bx) ? p2 : p1;

            int dx = (int)std::lround(R.bx - L.bx);
            int dy = (int)std::lround(std::fabs(R.by - L.by));
            if (dx < minDx || dx > maxDx) continue;
            if (dy > maxDy) continue;

            if ((int)std::lround(L.by) > faceCyInZone) continue;
            if ((int)std::lround(R.by) > faceCyInZone) continue;

            uint32_t score = (uint32_t)L.v + (uint32_t)R.v;
            if (!found || score > best) {
                found = true; best = score;
                left = L; right = R;
            }
        }
    }
    return found;
}

// -------------------- detection result --------------------
struct faceeyes {
    bool faceOk = false;
    int faceX = 0, faceY = 0;
    int faceRx = 0, faceRy = 0;

    int eyeRoiX = 0, eyeRoiY = 0, eyeRoiW = 0, eyeRoiH = 0;

    bool eyesOk = false;
    int ex1 = 0, ey1 = 0, ex2 = 0, ey2 = 0;
    int eyeR = 0;

    // debug
    ChampGradient dbgGrads;
    bool dbgFaceAccuOk = false;
    AccuImage dbgFaceAccu;
    bool dbgEyeAccuOk = false;
    AccuImage dbgEyeAccu;

    // debug peaks
    uint16_t dbgBestFacePeak = 0;
    uint16_t dbgBestEyePeak = 0;
};

static faceeyes detectfaceeyes_once(
    const grayImage& img,
    const std::vector<facemodel>& faceModels,
    const std::vector<eyemodel>& eyeModels,
    uint16_t seuilFace, uint16_t seuilEye,
    uint16_t faceMinScore, uint16_t eyeMinPeak
) {
    faceeyes out;
    out.dbgGrads = sobel(img);

    // FACE: best model by peak
    uint16_t bestPeak = 0;
    int bestX = 0, bestY = 0;
    int bestRx = 0, bestRy = 0;
    AccuImage bestAccu = makeAccu(img.w, img.h);

    for (const auto& fm : faceModels) {
        AccuImage A = makeAccu(img.w, img.h);
        voterWeighted(A, out.dbgGrads, fm.lut, seuilFace);

        int px=0, py=0;
        uint16_t peak = accuPeak(A, &px, &py);
        if (peak >= bestPeak) {
            bestPeak = peak;
            bestX = px; bestY = py;
            bestRx = fm.rx; bestRy = fm.ry;
            bestAccu = A;
        }
    }

    out.dbgFaceAccuOk = true;
    out.dbgFaceAccu = bestAccu;
    out.dbgBestFacePeak = bestPeak;

    if (bestPeak < faceMinScore) {
        out.faceOk = false;
        return out;
    }

    out.faceOk = true;
    out.faceX = bestX;
    out.faceY = bestY;
    out.faceRx = bestRx;
    out.faceRy = bestRy;

    // EYES ROI：上半脸区域（收紧，降低窗框边缘干扰）
    int zx0 = clampInt(bestX - (int)std::lround(bestRx * 1.15), 0, img.w - 1);
    int zx1 = clampInt(bestX + (int)std::lround(bestRx * 1.15), 0, img.w - 1);
    int zy0 = clampInt(bestY - (int)std::lround(bestRy * 1.10), 0, img.h - 1);
    int zy1 = clampInt(bestY - (int)std::lround(bestRy * 0.10), 0, img.h - 1);

    if (zx1 <= zx0 || zy1 <= zy0) {
        out.eyesOk = false;
        return out;
    }

    out.eyeRoiX = zx0; out.eyeRoiY = zy0;
    out.eyeRoiW = zx1 - zx0 + 1;
    out.eyeRoiH = zy1 - zy0 + 1;

    grayImage zone;
    zone.w = out.eyeRoiW;
    zone.h = out.eyeRoiH;
    zone.p.assign((size_t)zone.w * (size_t)zone.h, 0);
    for (int y = 0; y < zone.h; ++y)
        for (int x = 0; x < zone.w; ++x)
            zone.at(y, x) = img.at(zy0 + y, zx0 + x);

    ChampGradient gEye = sobel(zone);

    uint16_t bestEyePeak = 0;
    int bestR = 0;
    AccuImage bestEyeAccu = makeAccu(zone.w, zone.h);
    std::vector<PicPoint> bestPics;

    for (const auto& em : eyeModels) {
        AccuImage A = makeAccu(zone.w, zone.h);
        voterWeighted(A, gEye, em.lut, seuilEye);

        auto pics = topKpicsAvecBary(A, 8, em.r * 2, 6, eyeMinPeak);
        if (pics.empty()) continue;

        uint16_t localPeak = 0;
        for (auto& p : pics) localPeak = std::max<uint16_t>(localPeak, p.v);

        if (localPeak >= bestEyePeak) {
            bestEyePeak = localPeak;
            bestR = em.r;
            bestEyeAccu = A;
            bestPics = pics;
        }
    }

    out.dbgEyeAccuOk = true;
    out.dbgEyeAccu = bestEyeAccu;
    out.dbgBestEyePeak = bestEyePeak;

    if (bestPics.empty()) {
        out.eyesOk = false;
        return out;
    }

    PicPoint L, R;
    int minDx = std::max(10, (int)std::lround(bestRx * 0.55));
    int maxDx = std::max(minDx + 10, (int)std::lround(bestRx * 1.70));
    int maxDy = std::max(10, (int)std::lround(bestRy * 0.30));

    bool ok = choisirPaireYeux(bestPics, bestX - zx0, bestY - zy0, minDx, maxDx, maxDy, L, R);
    if (!ok) {
        out.eyesOk = false;
        return out;
    }

    out.eyesOk = true;
    out.eyeR = bestR;

    out.ex1 = zx0 + (int)std::lround(L.bx);
    out.ey1 = zy0 + (int)std::lround(L.by);
    out.ex2 = zx0 + (int)std::lround(R.bx);
    out.ey2 = zy0 + (int)std::lround(R.by);

    return out;
}

static void drawOverlay(cv::Mat& frame, const faceeyes& r) {
    if (r.faceOk) {
        cv::circle(frame, cv::Point(r.faceX, r.faceY), 6, cv::Scalar(0, 255, 0), 2);
    }
    if (r.eyeRoiW > 0 && r.eyeRoiH > 0) {
        cv::rectangle(frame, cv::Rect(r.eyeRoiX, r.eyeRoiY, r.eyeRoiW, r.eyeRoiH), cv::Scalar(255, 0, 0), 2);
    }
    if (r.eyesOk) {
        cv::circle(frame, cv::Point(r.ex1, r.ey1), r.eyeR, cv::Scalar(0, 255, 255), 2);
        cv::circle(frame, cv::Point(r.ex2, r.ey2), r.eyeR, cv::Scalar(0, 255, 255), 2);
    }
}

int main(int argc, char** argv) {
    bool doImage = false;
    std::string imagePath;

    bool imageGui = false;
    bool guiSteps = false;
    int guiDelayMs = 0;

    // preprocess
    bool useEqHist = true;
    bool useClahe = false;
    int blurK = 5;

    // thresholds
    bool autoThr = true;
    int faceEdgeUser = -1;
    int eyeEdgeUser  = -1;
    int faceMinUser  = -1;
    int eyeMinUser   = -1;

    for (int i = 1; i < argc; ++i) {
        std::string a = argv[i];

        if (a == "--image") { if (i + 1 < argc) { doImage = true; imagePath = argv[++i]; } continue; }
        if (a == "--gui") { imageGui = true; continue; }
        if (a == "--gui-steps") { imageGui = true; guiSteps = true; continue; }
        if (a == "--gui-delay-ms") { if (i + 1 < argc) { imageGui = true; guiDelayMs = std::max(0, std::atoi(argv[++i])); } continue; }
        if (a == "--no-gui" || a == "--headless") { imageGui = false; guiSteps = false; guiDelayMs = 0; continue; }

        if (a == "--no-eq") { useEqHist = false; continue; }
        if (a == "--clahe") { useClahe = true; continue; }
        if (a == "--blur") { if (i + 1 < argc) { blurK = std::atoi(argv[++i]); } continue; }

        if (a == "--no-auto-threshold") { autoThr = false; continue; }
        if (a == "--face-edge") { if (i + 1 < argc) { faceEdgeUser = std::atoi(argv[++i]); } continue; }
        if (a == "--eye-edge")  { if (i + 1 < argc) { eyeEdgeUser  = std::atoi(argv[++i]); } continue; }
        if (a == "--face-min-score") { if (i + 1 < argc) { faceMinUser = std::atoi(argv[++i]); } continue; }
        if (a == "--eye-min-peak")   { if (i + 1 < argc) { eyeMinUser  = std::atoi(argv[++i]); } continue; }
    }

    if (!doImage) {
        std::cerr
            << "Usage: ght_face_eyes --image <path> [--gui|--no-gui] [--gui-steps] [--gui-delay-ms N]\n"
            << "  preprocess:\n"
            << "    --no-eq | --clahe | --blur <oddK>\n"
            << "  thresholds:\n"
            << "    --no-auto-threshold --face-edge v --eye-edge v --face-min-score v --eye-min-peak v\n";
        return 2;
    }

    // defaults (可被 autoThr / user override 覆盖)
    uint16_t EDGE_FACE = 140;
    uint16_t EDGE_EYE  = 75;
    uint16_t FACE_MIN_SCORE = 14;
    uint16_t EYE_MIN_PEAK   = 5;

    if (faceEdgeUser >= 0) EDGE_FACE = (uint16_t)clampInt(faceEdgeUser, 0, 65535);
    if (eyeEdgeUser  >= 0) EDGE_EYE  = (uint16_t)clampInt(eyeEdgeUser, 0, 65535);
    if (faceMinUser  >= 0) FACE_MIN_SCORE = (uint16_t)clampInt(faceMinUser, 0, 65535);
    if (eyeMinUser   >= 0) EYE_MIN_PEAK   = (uint16_t)clampInt(eyeMinUser, 0, 65535);

    // Build models (更低的 minMag，避免 LUT 太稀)
    std::vector<facemodel> faceModels;
    {
        const int scales[][2] = { {25,45},{30,55},{35,65},{45,85},{55,105},{65,125},{75,145} };
        for (int i = 0; i < 7; ++i) {
            int rx = scales[i][0], ry = scales[i][1];
            int tw = 2 * rx + 60;
            int th = 2 * ry + 60;

            grayImage t = templateEllipse(tw, th, (float)rx, (float)ry);
            RTable lut = construireRTableDepuisTemplate(t, /*minMag*/10);

            faceModels.push_back({rx, ry, lut});
        }
    }

    std::vector<eyemodel> eyeModels;
    {
        for (int r = 6; r <= 18; r += 2) {
            int tw = 2 * r + 40;
            int th = 2 * r + 40;
            grayImage t = templateCercle(tw, th, (float)r);
            RTable lut = construireRTableDepuisTemplate(t, /*minMag*/8);
            eyeModels.push_back({r, lut});
        }
    }

    cv::Mat bgr = cv::imread(imagePath);
    if (bgr.empty()) { std::cerr << "Erreur: impossible de lire l'image: " << imagePath << "\n"; return 1; }

    cv::Mat gray;
    cv::cvtColor(bgr, gray, cv::COLOR_BGR2GRAY);

    if (useClahe) {
        cv::Ptr<cv::CLAHE> clahe = cv::createCLAHE(2.0, cv::Size(8, 8));
        clahe->apply(gray, gray);
    } else if (useEqHist) {
        cv::equalizeHist(gray, gray);
    }

    if (blurK > 0) {
        if (blurK % 2 == 0) blurK += 1;
        blurK = std::max(1, blurK);
        cv::GaussianBlur(gray, gray, cv::Size(blurK, blurK), 0.0);
    }

    grayImage g = matToGrayImageU8(gray);

    // 自动阈值（如果 user 没覆盖）
    if (autoThr && faceEdgeUser < 0 && eyeEdgeUser < 0) {
        ChampGradient cg = sobel(g);

        // 用分位数是可以的，但仍可能过硬；后面会做 multi-pass 再降
        std::vector<uint16_t> s;
        s.reserve((size_t)(cg.w * cg.h / 4));
        for (int y = 0; y < cg.h; y += 2)
            for (int x = 0; x < cg.w; x += 2)
                s.push_back(cg.m(y, x));
        if (!s.empty()) {
            auto pick = [&](double q) -> uint16_t {
                size_t idx = (size_t)std::lround(q * (double)(s.size() - 1));
                idx = std::min(idx, s.size() - 1);
                std::nth_element(s.begin(), s.begin() + idx, s.end());
                return s[idx];
            };
            uint16_t p90 = pick(0.90);
            uint16_t p80 = pick(0.80);

            EDGE_FACE = (uint16_t)clampInt((int)std::lround((double)p90 * 0.70), 15, 220);
            EDGE_EYE  = (uint16_t)clampInt((int)std::lround((double)p80 * 0.55), 10, 180);
        }
    }

    // 关键修复：multi-pass 降阈值，直到 face 至少出来
    // 你这种逆光窗框场景，单次阈值很容易让峰值起不来
    std::vector<uint16_t> faceTry = {
        EDGE_FACE,
        (uint16_t)std::max<int>(10, (int)std::lround(EDGE_FACE * 0.75)),
        (uint16_t)std::max<int>(10, (int)std::lround(EDGE_FACE * 0.55)),
        12
    };
    std::vector<uint16_t> eyeTry = {
        EDGE_EYE,
        (uint16_t)std::max<int>(8, (int)std::lround(EDGE_EYE * 0.75)),
        (uint16_t)std::max<int>(8, (int)std::lround(EDGE_EYE * 0.55)),
        8
    };

    faceeyes best;
    bool haveFace = false;

    for (uint16_t fEdge : faceTry) {
        faceeyes r = detectfaceeyes_once(g, faceModels, eyeModels, fEdge, EDGE_EYE, FACE_MIN_SCORE, EYE_MIN_PEAK);
        std::cerr << "[TRY] faceEdge=" << fEdge
                  << " eyeEdge=" << EDGE_EYE
                  << " facePeak=" << r.dbgBestFacePeak
                  << " eyePeak=" << r.dbgBestEyePeak
                  << " faceOk=" << (r.faceOk ? "1":"0")
                  << " eyesOk=" << (r.eyesOk ? "1":"0")
                  << "\n";
        if (r.faceOk) { best = r; haveFace = true; EDGE_FACE = fEdge; break; }
        best = r; // keep last for GUI
    }

    // 如果脸出来但眼没出来，再单独降 eyeEdge 多次尝试
    if (haveFace && !best.eyesOk) {
        faceeyes bestEyeAttempt = best;
        for (uint16_t eEdge : eyeTry) {
            faceeyes r = detectfaceeyes_once(g, faceModels, eyeModels, EDGE_FACE, eEdge, FACE_MIN_SCORE, EYE_MIN_PEAK);
            std::cerr << "[TRY-EYE] faceEdge=" << EDGE_FACE
                      << " eyeEdge=" << eEdge
                      << " facePeak=" << r.dbgBestFacePeak
                      << " eyePeak=" << r.dbgBestEyePeak
                      << " faceOk=" << (r.faceOk ? "1":"0")
                      << " eyesOk=" << (r.eyesOk ? "1":"0")
                      << "\n";
            if (r.faceOk && r.eyesOk) { bestEyeAttempt = r; EDGE_EYE = eEdge; break; }
            // 选 eyePeak 更大的作为“最接近成功”的结果（用于 GUI）
            if (r.dbgBestEyePeak > bestEyeAttempt.dbgBestEyePeak) bestEyeAttempt = r;
        }
        best = bestEyeAttempt;
    }

    // stdout: 解析兼容
    if (!best.faceOk) std::cout << "Face=NOTFOUND\n";
    else std::cout << "Face=(" << best.faceX << "," << best.faceY << ")\n";

    if (!best.eyesOk) std::cout << "Eyes=NOTFOUND\n";
    else std::cout << "Eyes=(" << best.ex1 << "," << best.ey1 << ") (" << best.ex2 << "," << best.ey2 << ") r=" << best.eyeR << "\n";

    std::cerr
        << "[DBG] EDGE_FACE=" << EDGE_FACE
        << " EDGE_EYE=" << EDGE_EYE
        << " FACE_MIN_SCORE=" << FACE_MIN_SCORE
        << " EYE_MIN_PEAK=" << EYE_MIN_PEAK
        << " autoThr=" << (autoThr ? "1":"0")
        << " eq=" << (useEqHist ? "1":"0")
        << " clahe=" << (useClahe ? "1":"0")
        << " blurK=" << blurK
        << " bestFacePeak=" << best.dbgBestFacePeak
        << " bestEyePeak=" << best.dbgBestEyePeak
        << "\n";

    if (imageGui) {
        cv::Mat overlay = bgr.clone();
        drawOverlay(overlay, best);

        showStep("Frame", overlay, guiSteps, guiDelayMs);
        showStep("Gray(pre)", gray, guiSteps, guiDelayMs);
        showStep("Sobel(norm)", toMatMag8_norm(best.dbgGrads), guiSteps, guiDelayMs);
        if (best.dbgFaceAccuOk) showStep("Accu Face (best scale)", toMatAccu8(best.dbgFaceAccu), guiSteps, guiDelayMs);
        if (best.dbgEyeAccuOk)  showStep("Accu Eyes (best radius)", toMatAccu8(best.dbgEyeAccu), guiSteps, guiDelayMs);

        if (!guiSteps && guiDelayMs <= 0) cv::waitKey(0);
    }

    return 0;
}


